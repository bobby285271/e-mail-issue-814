/* MoveHandler.c generated by valac 0.56.3, the Vala compiler
 * generated from MoveHandler.vala, do not modify */

/*-
 * Copyright 2018-2019 elementary, Inc. (https://elementary.io)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Authored by: David Hewitt <davidmhewitt@gmail.com>
 */

#include <glib-object.h>
#include <camel/camel.h>
#include <gee.h>
#include <glib.h>
#include <gio/gio.h>
#include <stdlib.h>
#include <string.h>
#include <gobject/gvaluecollector.h>

#if !defined(VALA_EXTERN)
#if defined(_MSC_VER)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define MAIL_TYPE_MOVE_HANDLER (mail_move_handler_get_type ())
#define MAIL_MOVE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAIL_TYPE_MOVE_HANDLER, MailMoveHandler))
#define MAIL_MOVE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MAIL_TYPE_MOVE_HANDLER, MailMoveHandlerClass))
#define MAIL_IS_MOVE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAIL_TYPE_MOVE_HANDLER))
#define MAIL_IS_MOVE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MAIL_TYPE_MOVE_HANDLER))
#define MAIL_MOVE_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MAIL_TYPE_MOVE_HANDLER, MailMoveHandlerClass))

typedef struct _MailMoveHandler MailMoveHandler;
typedef struct _MailMoveHandlerClass MailMoveHandlerClass;
typedef struct _MailMoveHandlerPrivate MailMoveHandlerPrivate;
typedef enum  {
	MAIL_MOVE_HANDLER_MOVE_TYPE_TRASH,
	MAIL_MOVE_HANDLER_MOVE_TYPE_ARCHIVE
} MailMoveHandlerMoveType;

#define MAIL_MOVE_HANDLER_TYPE_MOVE_TYPE (mail_move_handler_move_type_get_type ())
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _mail_move_handler_unref0(var) ((var == NULL) ? NULL : (var = (mail_move_handler_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_ptr_array_unref0(var) ((var == NULL) ? NULL : (var = (g_ptr_array_unref (var), NULL)))
typedef struct _MailMoveHandlerArchiveThreadsData MailMoveHandlerArchiveThreadsData;
#define __vala_CamelURL_free0(var) ((var == NULL) ? NULL : (var = (_vala_CamelURL_free (var), NULL)))

#define MAIL_BACKEND_TYPE_SESSION (mail_backend_session_get_type ())
#define MAIL_BACKEND_SESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAIL_BACKEND_TYPE_SESSION, MailBackendSession))
#define MAIL_BACKEND_SESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MAIL_BACKEND_TYPE_SESSION, MailBackendSessionClass))
#define MAIL_BACKEND_IS_SESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAIL_BACKEND_TYPE_SESSION))
#define MAIL_BACKEND_IS_SESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MAIL_BACKEND_TYPE_SESSION))
#define MAIL_BACKEND_SESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MAIL_BACKEND_TYPE_SESSION, MailBackendSessionClass))

typedef struct _MailBackendSession MailBackendSession;
typedef struct _MailBackendSessionClass MailBackendSessionClass;
typedef struct _MailMoveHandlerUndoLastMoveData MailMoveHandlerUndoLastMoveData;
typedef struct _MailParamSpecMoveHandler MailParamSpecMoveHandler;

struct _MailMoveHandler {
	GTypeInstance parent_instance;
	volatile int ref_count;
	MailMoveHandlerPrivate * priv;
};

struct _MailMoveHandlerClass {
	GTypeClass parent_class;
	void (*finalize) (MailMoveHandler *self);
};

struct _MailMoveHandlerPrivate {
	CamelFolder* src_folder;
	CamelFolder* dst_folder;
	GeeArrayList* moved_messages;
	guint timeout_id;
	MailMoveHandlerMoveType move_type;
};

struct _MailMoveHandlerArchiveThreadsData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	MailMoveHandler* self;
	CamelFolder* folder;
	GeeArrayList* threads;
	gint result;
	CamelFolder* _tmp0_;
	GeeArrayList* _tmp1_;
	GeeArrayList* _thread_list;
	gint _thread_size;
	GeeArrayList* _tmp2_;
	gint _tmp3_;
	gint _tmp4_;
	gint _thread_index;
	gint _tmp5_;
	gint _tmp6_;
	CamelFolderThreadNode* thread;
	GeeArrayList* _tmp7_;
	gpointer _tmp8_;
	CamelFolderThreadNode* _tmp9_;
	gchar* archive_folder_uri;
	gchar* _tmp10_;
	CamelStore* dest_store;
	gchar* dest_folder_name;
	gboolean _tmp11_;
	const gchar* _tmp12_;
	CamelStore* _tmp13_;
	gchar* _tmp14_;
	gboolean _tmp15_;
	GError* e;
	GError* _tmp16_;
	const gchar* _tmp17_;
	CamelFolder* _tmp18_;
	CamelStore* _tmp19_;
	const gchar* _tmp20_;
	CamelFolder* _tmp21_;
	CamelFolder* _tmp22_;
	GError* _vala1_e;
	GError* _tmp23_;
	const gchar* _tmp24_;
	CamelFolder* _tmp25_;
	GPtrArray* uids;
	GPtrArray* _tmp26_;
	GeeArrayList* _info_list;
	GeeArrayList* _tmp27_;
	gint _info_size;
	GeeArrayList* _tmp28_;
	gint _tmp29_;
	gint _tmp30_;
	gint _info_index;
	gint _tmp31_;
	gint _tmp32_;
	CamelMessageInfo* info;
	GeeArrayList* _tmp33_;
	gpointer _tmp34_;
	CamelMessageInfo* _tmp35_;
	GPtrArray* _tmp36_;
	CamelMessageInfo* _tmp37_;
	const gchar* _tmp38_;
	const gchar* _tmp39_;
	gchar* _tmp40_;
	CamelFolder* _tmp41_;
	CamelFolder* _tmp42_;
	gboolean _tmp43_;
	GPtrArray* _tmp44_;
	CamelFolder* _tmp45_;
	GeeArrayList* _tmp46_;
	gint _tmp47_;
	gint _tmp48_;
	CamelFolder* _tmp49_;
	CamelFolder* _tmp50_;
	GError* _vala2_e;
	GError* _tmp51_;
	const gchar* _tmp52_;
	GError* _inner_error1_;
	CamelFolder* _tmp53_;
	CamelFolder* _tmp54_;
	GError* _inner_error0_;
};

struct _MailMoveHandlerUndoLastMoveData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	MailMoveHandler* self;
	CamelFolder* _tmp0_;
	GeeArrayList* _info_list;
	GeeArrayList* _tmp1_;
	gint _info_size;
	GeeArrayList* _tmp2_;
	gint _tmp3_;
	gint _tmp4_;
	gint _info_index;
	gint _tmp5_;
	gint _tmp6_;
	CamelMessageInfo* info;
	GeeArrayList* _tmp7_;
	gpointer _tmp8_;
	CamelMessageInfo* _tmp9_;
	CamelMessageInfo* _tmp10_;
	CamelFolder* _tmp11_;
};

struct _MailParamSpecMoveHandler {
	GParamSpec parent_instance;
};

static gint MailMoveHandler_private_offset;
static gpointer mail_move_handler_parent_class = NULL;

VALA_EXTERN gpointer mail_move_handler_ref (gpointer instance);
VALA_EXTERN void mail_move_handler_unref (gpointer instance);
VALA_EXTERN GParamSpec* mail_param_spec_move_handler (const gchar* name,
                                          const gchar* nick,
                                          const gchar* blurb,
                                          GType object_type,
                                          GParamFlags flags);
VALA_EXTERN void mail_value_set_move_handler (GValue* value,
                                  gpointer v_object);
VALA_EXTERN void mail_value_take_move_handler (GValue* value,
                                   gpointer v_object);
VALA_EXTERN gpointer mail_value_get_move_handler (const GValue* value);
VALA_EXTERN GType mail_move_handler_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (MailMoveHandler, mail_move_handler_unref)
static GType mail_move_handler_move_type_get_type (void) G_GNUC_CONST  G_GNUC_UNUSED ;
VALA_EXTERN gint mail_move_handler_delete_threads (MailMoveHandler* self,
                                       CamelFolder* folder,
                                       GeeArrayList* threads);
static void mail_move_handler_collect_thread_messages (MailMoveHandler* self,
                                                CamelFolderThreadNode* thread);
static gboolean __lambda22_ (MailMoveHandler* self);
VALA_EXTERN void mail_move_handler_expire_undo (MailMoveHandler* self);
static gboolean ___lambda22__gsource_func (gpointer self);
static void mail_move_handler_archive_threads_data_free (gpointer _data);
VALA_EXTERN void mail_move_handler_archive_threads (MailMoveHandler* self,
                                        CamelFolder* folder,
                                        GeeArrayList* threads,
                                        GAsyncReadyCallback _callback_,
                                        gpointer _user_data_);
VALA_EXTERN gint mail_move_handler_archive_threads_finish (MailMoveHandler* self,
                                               GAsyncResult* _res_);
static gboolean mail_move_handler_archive_threads_co (MailMoveHandlerArchiveThreadsData* _data_);
static gchar* mail_move_handler_get_archive_folder_uri_from_folder (MailMoveHandler* self,
                                                             CamelFolder* folder);
static gboolean mail_move_handler_get_folder_from_uri (MailMoveHandler* self,
                                                const gchar* uri,
                                                CamelStore** store,
                                                gchar** folder_name,
                                                GError** error);
static void mail_move_handler_archive_threads_ready (GObject* source_object,
                                              GAsyncResult* _res_,
                                              gpointer _user_data_);
static void _g_free0_ (gpointer var);
static gboolean ____lambda23_ (MailMoveHandler* self);
static gboolean _____lambda23__gsource_func (gpointer self);
static void _vala_CamelURL_free (CamelURL* self);
VALA_EXTERN GType mail_backend_session_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (MailBackendSession, g_object_unref)
VALA_EXTERN MailBackendSession* mail_backend_session_get_default (void);
VALA_EXTERN gchar* mail_backend_session_get_archive_folder_uri_for_service (MailBackendSession* self,
                                                                CamelService* service);
static void mail_move_handler_undo_last_move_data_free (gpointer _data);
VALA_EXTERN void mail_move_handler_undo_last_move (MailMoveHandler* self,
                                       GAsyncReadyCallback _callback_,
                                       gpointer _user_data_);
VALA_EXTERN void mail_move_handler_undo_last_move_finish (MailMoveHandler* self,
                                              GAsyncResult* _res_);
static gboolean mail_move_handler_undo_last_move_co (MailMoveHandlerUndoLastMoveData* _data_);
VALA_EXTERN MailMoveHandler* mail_move_handler_new (void);
VALA_EXTERN MailMoveHandler* mail_move_handler_construct (GType object_type);
static void mail_move_handler_finalize (MailMoveHandler * obj);
static GType mail_move_handler_get_type_once (void);

static inline gpointer
mail_move_handler_get_instance_private (MailMoveHandler* self)
{
	return G_STRUCT_MEMBER_P (self, MailMoveHandler_private_offset);
}

static GType
mail_move_handler_move_type_get_type_once (void)
{
	static const GEnumValue values[] = {{MAIL_MOVE_HANDLER_MOVE_TYPE_TRASH, "MAIL_MOVE_HANDLER_MOVE_TYPE_TRASH", "trash"}, {MAIL_MOVE_HANDLER_MOVE_TYPE_ARCHIVE, "MAIL_MOVE_HANDLER_MOVE_TYPE_ARCHIVE", "archive"}, {0, NULL, NULL}};
	GType mail_move_handler_move_type_type_id;
	mail_move_handler_move_type_type_id = g_enum_register_static ("MailMoveHandlerMoveType", values);
	return mail_move_handler_move_type_type_id;
}

static GType
mail_move_handler_move_type_get_type (void)
{
	static volatile gsize mail_move_handler_move_type_type_id__once = 0;
	if (g_once_init_enter (&mail_move_handler_move_type_type_id__once)) {
		GType mail_move_handler_move_type_type_id;
		mail_move_handler_move_type_type_id = mail_move_handler_move_type_get_type_once ();
		g_once_init_leave (&mail_move_handler_move_type_type_id__once, mail_move_handler_move_type_type_id);
	}
	return mail_move_handler_move_type_type_id__once;
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

static gboolean
__lambda22_ (MailMoveHandler* self)
{
	gboolean result;
	mail_move_handler_expire_undo (self);
	self->priv->timeout_id = (guint) 0;
	result = G_SOURCE_REMOVE;
	return result;
}

static gboolean
___lambda22__gsource_func (gpointer self)
{
	gboolean result;
	result = __lambda22_ ((MailMoveHandler*) self);
	return result;
}

gint
mail_move_handler_delete_threads (MailMoveHandler* self,
                                  CamelFolder* folder,
                                  GeeArrayList* threads)
{
	CamelFolder* _tmp0_;
	GeeArrayList* _tmp1_;
	CamelFolder* _tmp10_;
	CamelFolder* _tmp21_;
	GeeArrayList* _tmp22_;
	gint _tmp23_;
	gint _tmp24_;
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (folder != NULL, 0);
	g_return_val_if_fail (threads != NULL, 0);
	_tmp0_ = _g_object_ref0 (folder);
	_g_object_unref0 (self->priv->src_folder);
	self->priv->src_folder = _tmp0_;
	_g_object_unref0 (self->priv->dst_folder);
	self->priv->dst_folder = NULL;
	self->priv->move_type = MAIL_MOVE_HANDLER_MOVE_TYPE_TRASH;
	_tmp1_ = gee_array_list_new (camel_message_info_get_type (), NULL, NULL, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->moved_messages);
	self->priv->moved_messages = _tmp1_;
	{
		GeeArrayList* _thread_list = NULL;
		gint _thread_size = 0;
		GeeArrayList* _tmp2_;
		gint _tmp3_;
		gint _tmp4_;
		gint _thread_index = 0;
		_thread_list = threads;
		_tmp2_ = _thread_list;
		_tmp3_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp2_);
		_tmp4_ = _tmp3_;
		_thread_size = _tmp4_;
		_thread_index = -1;
		while (TRUE) {
			gint _tmp5_;
			gint _tmp6_;
			CamelFolderThreadNode* thread = NULL;
			GeeArrayList* _tmp7_;
			gpointer _tmp8_;
			CamelFolderThreadNode* _tmp9_;
			_thread_index = _thread_index + 1;
			_tmp5_ = _thread_index;
			_tmp6_ = _thread_size;
			if (!(_tmp5_ < _tmp6_)) {
				break;
			}
			_tmp7_ = _thread_list;
			_tmp8_ = gee_abstract_list_get ((GeeAbstractList*) _tmp7_, _thread_index);
			thread = (CamelFolderThreadNode*) _tmp8_;
			_tmp9_ = thread;
			mail_move_handler_collect_thread_messages (self, _tmp9_);
		}
	}
	_tmp10_ = self->priv->src_folder;
	camel_folder_freeze (_tmp10_);
	self->priv->timeout_id = g_timeout_add_seconds_full (G_PRIORITY_DEFAULT, (guint) 10, ___lambda22__gsource_func, mail_move_handler_ref (self), mail_move_handler_unref);
	{
		GeeArrayList* _info_list = NULL;
		GeeArrayList* _tmp11_;
		gint _info_size = 0;
		GeeArrayList* _tmp12_;
		gint _tmp13_;
		gint _tmp14_;
		gint _info_index = 0;
		_tmp11_ = self->priv->moved_messages;
		_info_list = _tmp11_;
		_tmp12_ = _info_list;
		_tmp13_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp12_);
		_tmp14_ = _tmp13_;
		_info_size = _tmp14_;
		_info_index = -1;
		while (TRUE) {
			gint _tmp15_;
			gint _tmp16_;
			CamelMessageInfo* info = NULL;
			GeeArrayList* _tmp17_;
			gpointer _tmp18_;
			CamelMessageInfo* _tmp19_;
			CamelMessageInfo* _tmp20_;
			_info_index = _info_index + 1;
			_tmp15_ = _info_index;
			_tmp16_ = _info_size;
			if (!(_tmp15_ < _tmp16_)) {
				break;
			}
			_tmp17_ = _info_list;
			_tmp18_ = gee_abstract_list_get ((GeeAbstractList*) _tmp17_, _info_index);
			_tmp19_ = _g_object_ref0 ((CamelMessageInfo*) _tmp18_);
			info = _tmp19_;
			_tmp20_ = info;
			camel_message_info_set_flags (_tmp20_, (guint32) CAMEL_MESSAGE_DELETED, (guint32) (~0));
			_g_object_unref0 (info);
		}
	}
	_tmp21_ = self->priv->src_folder;
	camel_folder_thaw (_tmp21_);
	_tmp22_ = self->priv->moved_messages;
	_tmp23_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp22_);
	_tmp24_ = _tmp23_;
	result = _tmp24_;
	return result;
}

static void
mail_move_handler_archive_threads_data_free (gpointer _data)
{
	MailMoveHandlerArchiveThreadsData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->folder);
	_g_object_unref0 (_data_->threads);
	_mail_move_handler_unref0 (_data_->self);
	g_slice_free (MailMoveHandlerArchiveThreadsData, _data_);
}

static gpointer
_mail_move_handler_ref0 (gpointer self)
{
	return self ? mail_move_handler_ref (self) : NULL;
}

void
mail_move_handler_archive_threads (MailMoveHandler* self,
                                   CamelFolder* folder,
                                   GeeArrayList* threads,
                                   GAsyncReadyCallback _callback_,
                                   gpointer _user_data_)
{
	MailMoveHandlerArchiveThreadsData* _data_;
	MailMoveHandler* _tmp0_;
	CamelFolder* _tmp1_;
	GeeArrayList* _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (folder != NULL);
	g_return_if_fail (threads != NULL);
	_data_ = g_slice_new0 (MailMoveHandlerArchiveThreadsData);
	_data_->_async_result = g_task_new (NULL, NULL, _callback_, _user_data_);
	g_task_set_task_data (_data_->_async_result, _data_, mail_move_handler_archive_threads_data_free);
	_tmp0_ = _mail_move_handler_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = _g_object_ref0 (folder);
	_g_object_unref0 (_data_->folder);
	_data_->folder = _tmp1_;
	_tmp2_ = _g_object_ref0 (threads);
	_g_object_unref0 (_data_->threads);
	_data_->threads = _tmp2_;
	mail_move_handler_archive_threads_co (_data_);
}

gint
mail_move_handler_archive_threads_finish (MailMoveHandler* self,
                                          GAsyncResult* _res_)
{
	gint result;
	MailMoveHandlerArchiveThreadsData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
	result = _data_->result;
	return result;
}

static void
mail_move_handler_archive_threads_ready (GObject* source_object,
                                         GAsyncResult* _res_,
                                         gpointer _user_data_)
{
	MailMoveHandlerArchiveThreadsData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	mail_move_handler_archive_threads_co (_data_);
}

static void
_g_free0_ (gpointer var)
{
	var = (g_free (var), NULL);
}

static gboolean
____lambda23_ (MailMoveHandler* self)
{
	gboolean result;
	mail_move_handler_expire_undo (self);
	self->priv->timeout_id = (guint) 0;
	result = G_SOURCE_REMOVE;
	return result;
}

static gboolean
_____lambda23__gsource_func (gpointer self)
{
	gboolean result;
	result = ____lambda23_ ((MailMoveHandler*) self);
	return result;
}

static gboolean
mail_move_handler_archive_threads_co (MailMoveHandlerArchiveThreadsData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		case 2:
		goto _state_2;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = _g_object_ref0 (_data_->folder);
	_g_object_unref0 (_data_->self->priv->src_folder);
	_data_->self->priv->src_folder = _data_->_tmp0_;
	_data_->self->priv->move_type = MAIL_MOVE_HANDLER_MOVE_TYPE_ARCHIVE;
	_data_->_tmp1_ = gee_array_list_new (camel_message_info_get_type (), NULL, NULL, NULL, NULL, NULL);
	_g_object_unref0 (_data_->self->priv->moved_messages);
	_data_->self->priv->moved_messages = _data_->_tmp1_;
	{
		_data_->_thread_list = _data_->threads;
		_data_->_tmp2_ = _data_->_thread_list;
		_data_->_tmp3_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _data_->_tmp2_);
		_data_->_tmp4_ = _data_->_tmp3_;
		_data_->_thread_size = _data_->_tmp4_;
		_data_->_thread_index = -1;
		while (TRUE) {
			_data_->_thread_index = _data_->_thread_index + 1;
			_data_->_tmp5_ = _data_->_thread_index;
			_data_->_tmp6_ = _data_->_thread_size;
			if (!(_data_->_tmp5_ < _data_->_tmp6_)) {
				break;
			}
			_data_->_tmp7_ = _data_->_thread_list;
			_data_->_tmp8_ = gee_abstract_list_get ((GeeAbstractList*) _data_->_tmp7_, _data_->_thread_index);
			_data_->thread = (CamelFolderThreadNode*) _data_->_tmp8_;
			_data_->_tmp9_ = _data_->thread;
			mail_move_handler_collect_thread_messages (_data_->self, _data_->_tmp9_);
		}
	}
	_data_->_tmp10_ = mail_move_handler_get_archive_folder_uri_from_folder (_data_->self, _data_->folder);
	_data_->archive_folder_uri = _data_->_tmp10_;
	{
		_data_->_tmp12_ = _data_->archive_folder_uri;
		_data_->_tmp13_ = NULL;
		_data_->_tmp14_ = NULL;
		_data_->_tmp15_ = mail_move_handler_get_folder_from_uri (_data_->self, _data_->_tmp12_, &_data_->_tmp13_, &_data_->_tmp14_, &_data_->_inner_error0_);
		_g_object_unref0 (_data_->dest_store);
		_data_->dest_store = _data_->_tmp13_;
		_g_free0 (_data_->dest_folder_name);
		_data_->dest_folder_name = _data_->_tmp14_;
		_data_->_tmp11_ = _data_->_tmp15_;
		if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
			goto __catch0_g_error;
		}
		if (!_data_->_tmp11_) {
			_data_->result = 0;
			_g_free0 (_data_->dest_folder_name);
			_g_object_unref0 (_data_->dest_store);
			_g_free0 (_data_->archive_folder_uri);
			g_task_return_pointer (_data_->_async_result, _data_, NULL);
			if (_data_->_state_ != 0) {
				while (!g_task_get_completed (_data_->_async_result)) {
					g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
				}
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		}
	}
	goto __finally0;
	__catch0_g_error:
	{
		_data_->e = _data_->_inner_error0_;
		_data_->_inner_error0_ = NULL;
		_data_->_tmp16_ = _data_->e;
		_data_->_tmp17_ = _data_->_tmp16_->message;
		g_warning ("MoveHandler.vala:78: Unable to get archive folder from uri: %s", _data_->_tmp17_);
		_data_->result = 0;
		_g_error_free0 (_data_->e);
		_g_free0 (_data_->dest_folder_name);
		_g_object_unref0 (_data_->dest_store);
		_g_free0 (_data_->archive_folder_uri);
		g_task_return_pointer (_data_->_async_result, _data_, NULL);
		if (_data_->_state_ != 0) {
			while (!g_task_get_completed (_data_->_async_result)) {
				g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
			}
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	__finally0:
	if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
		_g_free0 (_data_->dest_folder_name);
		_g_object_unref0 (_data_->dest_store);
		_g_free0 (_data_->archive_folder_uri);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error0_->message, g_quark_to_string (_data_->_inner_error0_->domain), _data_->_inner_error0_->code);
		g_clear_error (&_data_->_inner_error0_);
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_g_object_unref0 (_data_->self->priv->dst_folder);
	_data_->self->priv->dst_folder = NULL;
	{
		_data_->_tmp19_ = _data_->dest_store;
		_data_->_tmp20_ = _data_->dest_folder_name;
		_data_->_state_ = 1;
		camel_store_get_folder (_data_->_tmp19_, _data_->_tmp20_, CAMEL_STORE_FOLDER_NONE, G_PRIORITY_DEFAULT, NULL, mail_move_handler_archive_threads_ready, _data_);
		return FALSE;
		_state_1:
		_data_->_tmp21_ = camel_store_get_folder_finish (_data_->_tmp19_, _data_->_res_, &_data_->_inner_error0_);
		_data_->_tmp18_ = _data_->_tmp21_;
		if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
			goto __catch1_g_error;
		}
		_data_->_tmp22_ = _data_->_tmp18_;
		_data_->_tmp18_ = NULL;
		_g_object_unref0 (_data_->self->priv->dst_folder);
		_data_->self->priv->dst_folder = _data_->_tmp22_;
		_g_object_unref0 (_data_->_tmp18_);
	}
	goto __finally1;
	__catch1_g_error:
	{
		_data_->_vala1_e = _data_->_inner_error0_;
		_data_->_inner_error0_ = NULL;
		_data_->_tmp23_ = _data_->_vala1_e;
		_data_->_tmp24_ = _data_->_tmp23_->message;
		g_warning ("MoveHandler.vala:86: Unable to get destination folder for archive: %s", _data_->_tmp24_);
		_data_->result = 0;
		_g_error_free0 (_data_->_vala1_e);
		_g_free0 (_data_->dest_folder_name);
		_g_object_unref0 (_data_->dest_store);
		_g_free0 (_data_->archive_folder_uri);
		g_task_return_pointer (_data_->_async_result, _data_, NULL);
		if (_data_->_state_ != 0) {
			while (!g_task_get_completed (_data_->_async_result)) {
				g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
			}
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	__finally1:
	if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
		_g_free0 (_data_->dest_folder_name);
		_g_object_unref0 (_data_->dest_store);
		_g_free0 (_data_->archive_folder_uri);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error0_->message, g_quark_to_string (_data_->_inner_error0_->domain), _data_->_inner_error0_->code);
		g_clear_error (&_data_->_inner_error0_);
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->_tmp25_ = _data_->self->priv->dst_folder;
	if (_data_->_tmp25_ == NULL) {
		_data_->result = 0;
		_g_free0 (_data_->dest_folder_name);
		_g_object_unref0 (_data_->dest_store);
		_g_free0 (_data_->archive_folder_uri);
		g_task_return_pointer (_data_->_async_result, _data_, NULL);
		if (_data_->_state_ != 0) {
			while (!g_task_get_completed (_data_->_async_result)) {
				g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
			}
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->_tmp26_ = g_ptr_array_new_full ((guint) 0, _g_free0_);
	_data_->uids = _data_->_tmp26_;
	{
		_data_->_tmp27_ = _data_->self->priv->moved_messages;
		_data_->_info_list = _data_->_tmp27_;
		_data_->_tmp28_ = _data_->_info_list;
		_data_->_tmp29_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _data_->_tmp28_);
		_data_->_tmp30_ = _data_->_tmp29_;
		_data_->_info_size = _data_->_tmp30_;
		_data_->_info_index = -1;
		while (TRUE) {
			_data_->_info_index = _data_->_info_index + 1;
			_data_->_tmp31_ = _data_->_info_index;
			_data_->_tmp32_ = _data_->_info_size;
			if (!(_data_->_tmp31_ < _data_->_tmp32_)) {
				break;
			}
			_data_->_tmp33_ = _data_->_info_list;
			_data_->_tmp34_ = gee_abstract_list_get ((GeeAbstractList*) _data_->_tmp33_, _data_->_info_index);
			_data_->_tmp35_ = _g_object_ref0 ((CamelMessageInfo*) _data_->_tmp34_);
			_data_->info = _data_->_tmp35_;
			_data_->_tmp36_ = _data_->uids;
			_data_->_tmp37_ = _data_->info;
			_data_->_tmp38_ = camel_message_info_get_uid (_data_->_tmp37_);
			_data_->_tmp39_ = _data_->_tmp38_;
			_data_->_tmp40_ = g_strdup (_data_->_tmp39_);
			g_ptr_array_add (_data_->_tmp36_, _data_->_tmp40_);
			_g_object_unref0 (_data_->info);
		}
	}
	_data_->_tmp41_ = _data_->self->priv->dst_folder;
	camel_folder_freeze (_data_->_tmp41_);
	_data_->_tmp42_ = _data_->self->priv->src_folder;
	camel_folder_freeze (_data_->_tmp42_);
	{
		_data_->_tmp44_ = _data_->uids;
		_data_->_tmp45_ = _data_->self->priv->dst_folder;
		_data_->_state_ = 2;
		camel_folder_transfer_messages_to (_data_->folder, _data_->_tmp44_, _data_->_tmp45_, TRUE, G_PRIORITY_DEFAULT, NULL, mail_move_handler_archive_threads_ready, _data_);
		return FALSE;
		_state_2:
		_data_->_tmp43_ = camel_folder_transfer_messages_to_finish (_data_->folder, _data_->_res_, NULL, &_data_->_inner_error0_);
		if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
			goto __catch2_g_error;
		}
		if (_data_->_tmp43_) {
			_data_->self->priv->timeout_id = g_timeout_add_seconds_full (G_PRIORITY_DEFAULT, (guint) 10, _____lambda23__gsource_func, mail_move_handler_ref (_data_->self), mail_move_handler_unref);
			_data_->_tmp46_ = _data_->self->priv->moved_messages;
			_data_->_tmp47_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _data_->_tmp46_);
			_data_->_tmp48_ = _data_->_tmp47_;
			_data_->result = _data_->_tmp48_;
			{
				_data_->_tmp49_ = _data_->self->priv->src_folder;
				camel_folder_thaw (_data_->_tmp49_);
				_data_->_tmp50_ = _data_->self->priv->dst_folder;
				camel_folder_thaw (_data_->_tmp50_);
			}
			_g_ptr_array_unref0 (_data_->uids);
			_g_free0 (_data_->dest_folder_name);
			_g_object_unref0 (_data_->dest_store);
			_g_free0 (_data_->archive_folder_uri);
			g_task_return_pointer (_data_->_async_result, _data_, NULL);
			if (_data_->_state_ != 0) {
				while (!g_task_get_completed (_data_->_async_result)) {
					g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
				}
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		}
	}
	goto __finally2;
	__catch2_g_error:
	{
		_data_->_vala2_e = _data_->_inner_error0_;
		_data_->_inner_error0_ = NULL;
		_data_->_tmp51_ = _data_->_vala2_e;
		_data_->_tmp52_ = _data_->_tmp51_->message;
		g_warning ("MoveHandler.vala:113: Unable to archive messages due to an unexpected " \
"error: %s", _data_->_tmp52_);
		_g_error_free0 (_data_->_vala2_e);
	}
	__finally2:
	{
		_data_->_tmp53_ = _data_->self->priv->src_folder;
		camel_folder_thaw (_data_->_tmp53_);
		_data_->_tmp54_ = _data_->self->priv->dst_folder;
		camel_folder_thaw (_data_->_tmp54_);
	}
	if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
		_g_ptr_array_unref0 (_data_->uids);
		_g_free0 (_data_->dest_folder_name);
		_g_object_unref0 (_data_->dest_store);
		_g_free0 (_data_->archive_folder_uri);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error0_->message, g_quark_to_string (_data_->_inner_error0_->domain), _data_->_inner_error0_->code);
		g_clear_error (&_data_->_inner_error0_);
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->result = 0;
	_g_ptr_array_unref0 (_data_->uids);
	_g_free0 (_data_->dest_folder_name);
	_g_object_unref0 (_data_->dest_store);
	_g_free0 (_data_->archive_folder_uri);
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (!g_task_get_completed (_data_->_async_result)) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}

static void
_vala_CamelURL_free (CamelURL* self)
{
	g_boxed_free (camel_url_get_type (), self);
}

static glong
string_strnlen (gchar* str,
                glong maxlen)
{
	gchar* end = NULL;
	gchar* _tmp0_;
	gchar* _tmp1_;
	glong result;
	_tmp0_ = memchr (str, 0, (gsize) maxlen);
	end = _tmp0_;
	_tmp1_ = end;
	if (_tmp1_ == NULL) {
		result = maxlen;
		return result;
	} else {
		gchar* _tmp2_;
		_tmp2_ = end;
		result = (glong) (_tmp2_ - str);
		return result;
	}
}

static gchar*
string_substring (const gchar* self,
                  glong offset,
                  glong len)
{
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	gchar* _tmp3_;
	gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	if (offset >= ((glong) 0)) {
		_tmp0_ = len >= ((glong) 0);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		string_length = string_strnlen ((gchar*) self, offset + len);
	} else {
		gint _tmp1_;
		gint _tmp2_;
		_tmp1_ = strlen (self);
		_tmp2_ = _tmp1_;
		string_length = (glong) _tmp2_;
	}
	if (offset < ((glong) 0)) {
		offset = string_length + offset;
		g_return_val_if_fail (offset >= ((glong) 0), NULL);
	} else {
		g_return_val_if_fail (offset <= string_length, NULL);
	}
	if (len < ((glong) 0)) {
		len = string_length - offset;
	}
	g_return_val_if_fail ((offset + len) <= string_length, NULL);
	_tmp3_ = g_strndup (((gchar*) self) + offset, (gsize) len);
	result = _tmp3_;
	return result;
}

static gboolean
mail_move_handler_get_folder_from_uri (MailMoveHandler* self,
                                       const gchar* uri,
                                       CamelStore** store,
                                       gchar** folder_name,
                                       GError** error)
{
	CamelStore* _vala_store = NULL;
	gchar* _vala_folder_name = NULL;
	CamelURL* url = NULL;
	CamelURL* _tmp0_ = NULL;
	CamelURL* _tmp1_;
	CamelURL* _tmp3_;
	CamelURL* _tmp4_;
	CamelService* service = NULL;
	gchar* parsed_folder_name = NULL;
	CamelURL* _tmp5_;
	const gchar* _tmp6_;
	gboolean _tmp37_ = FALSE;
	gboolean _tmp38_ = FALSE;
	CamelService* _tmp39_;
	GError* _inner_error0_ = NULL;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (uri != NULL, FALSE);
	_g_object_unref0 (_vala_store);
	_vala_store = NULL;
	_g_free0 (_vala_folder_name);
	_vala_folder_name = NULL;
	url = NULL;
	_tmp1_ = camel_url_new (uri, &_inner_error0_);
	_tmp0_ = _tmp1_;
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		gboolean _tmp2_ = FALSE;
		g_propagate_error (error, _inner_error0_);
		__vala_CamelURL_free0 (url);
		_g_object_unref0 (_vala_store);
		_g_free0 (_vala_folder_name);
		return _tmp2_;
	}
	_tmp3_ = _tmp0_;
	_tmp0_ = NULL;
	__vala_CamelURL_free0 (url);
	url = _tmp3_;
	_tmp4_ = url;
	if (_tmp4_ == NULL) {
		result = FALSE;
		__vala_CamelURL_free0 (_tmp0_);
		__vala_CamelURL_free0 (url);
		if (store) {
			*store = _vala_store;
		} else {
			_g_object_unref0 (_vala_store);
		}
		if (folder_name) {
			*folder_name = _vala_folder_name;
		} else {
			_g_free0 (_vala_folder_name);
		}
		return result;
	}
	service = NULL;
	parsed_folder_name = NULL;
	_tmp5_ = url;
	_tmp6_ = _tmp5_->protocol;
	if (g_strcmp0 (_tmp6_, "folder") == 0) {
		CamelURL* _tmp7_;
		const gchar* _tmp8_;
		gboolean _tmp27_ = FALSE;
		CamelURL* _tmp28_;
		const gchar* _tmp29_;
		_tmp7_ = url;
		_tmp8_ = _tmp7_->host;
		if (_tmp8_ != NULL) {
			gchar* uid = NULL;
			gboolean _tmp9_ = FALSE;
			CamelURL* _tmp10_;
			const gchar* _tmp11_;
			MailBackendSession* _tmp24_;
			const gchar* _tmp25_;
			CamelService* _tmp26_;
			_tmp10_ = url;
			_tmp11_ = _tmp10_->user;
			if (_tmp11_ == NULL) {
				_tmp9_ = TRUE;
			} else {
				CamelURL* _tmp12_;
				const gchar* _tmp13_;
				_tmp12_ = url;
				_tmp13_ = _tmp12_->user;
				_tmp9_ = g_strcmp0 (_tmp13_, "") == 0;
			}
			if (_tmp9_) {
				CamelURL* _tmp14_;
				const gchar* _tmp15_;
				gchar* _tmp16_;
				_tmp14_ = url;
				_tmp15_ = _tmp14_->host;
				_tmp16_ = g_strdup (_tmp15_);
				_g_free0 (uid);
				uid = _tmp16_;
			} else {
				CamelURL* _tmp17_;
				const gchar* _tmp18_;
				gchar* _tmp19_;
				gchar* _tmp20_;
				CamelURL* _tmp21_;
				const gchar* _tmp22_;
				gchar* _tmp23_;
				_tmp17_ = url;
				_tmp18_ = _tmp17_->user;
				_tmp19_ = g_strconcat (_tmp18_, "@", NULL);
				_tmp20_ = _tmp19_;
				_tmp21_ = url;
				_tmp22_ = _tmp21_->host;
				_tmp23_ = g_strconcat (_tmp20_, _tmp22_, NULL);
				_g_free0 (uid);
				uid = _tmp23_;
				_g_free0 (_tmp20_);
			}
			_tmp24_ = mail_backend_session_get_default ();
			_tmp25_ = uid;
			_tmp26_ = camel_session_ref_service ((CamelSession*) _tmp24_, _tmp25_);
			_g_object_unref0 (service);
			service = _tmp26_;
			_g_free0 (uid);
		}
		_tmp28_ = url;
		_tmp29_ = _tmp28_->path;
		if (_tmp29_ != NULL) {
			CamelURL* _tmp30_;
			const gchar* _tmp31_;
			_tmp30_ = url;
			_tmp31_ = _tmp30_->path;
			_tmp27_ = g_str_has_prefix (_tmp31_, "/");
		} else {
			_tmp27_ = FALSE;
		}
		if (_tmp27_) {
			CamelURL* _tmp32_;
			const gchar* _tmp33_;
			gchar* _tmp34_;
			gchar* _tmp35_;
			gchar* _tmp36_;
			_tmp32_ = url;
			_tmp33_ = _tmp32_->path;
			_tmp34_ = string_substring (_tmp33_, (glong) 1, (glong) -1);
			_tmp35_ = _tmp34_;
			_tmp36_ = camel_url_decode_path (_tmp35_);
			_g_free0 (parsed_folder_name);
			parsed_folder_name = _tmp36_;
			_g_free0 (_tmp35_);
		}
	}
	_tmp39_ = service;
	if (_tmp39_ != NULL) {
		CamelService* _tmp40_;
		_tmp40_ = service;
		_tmp38_ = G_TYPE_CHECK_INSTANCE_TYPE (_tmp40_, camel_store_get_type ());
	} else {
		_tmp38_ = FALSE;
	}
	if (_tmp38_) {
		const gchar* _tmp41_;
		_tmp41_ = parsed_folder_name;
		_tmp37_ = _tmp41_ != NULL;
	} else {
		_tmp37_ = FALSE;
	}
	if (_tmp37_) {
		CamelService* _tmp42_;
		CamelStore* _tmp43_;
		const gchar* _tmp44_;
		gchar* _tmp45_;
		_tmp42_ = service;
		_tmp43_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp42_, camel_store_get_type (), CamelStore));
		_g_object_unref0 (_vala_store);
		_vala_store = _tmp43_;
		_tmp44_ = parsed_folder_name;
		_tmp45_ = g_strdup (_tmp44_);
		_g_free0 (_vala_folder_name);
		_vala_folder_name = _tmp45_;
		result = TRUE;
		_g_free0 (parsed_folder_name);
		_g_object_unref0 (service);
		__vala_CamelURL_free0 (_tmp0_);
		__vala_CamelURL_free0 (url);
		if (store) {
			*store = _vala_store;
		} else {
			_g_object_unref0 (_vala_store);
		}
		if (folder_name) {
			*folder_name = _vala_folder_name;
		} else {
			_g_free0 (_vala_folder_name);
		}
		return result;
	}
	result = FALSE;
	_g_free0 (parsed_folder_name);
	_g_object_unref0 (service);
	__vala_CamelURL_free0 (_tmp0_);
	__vala_CamelURL_free0 (url);
	if (store) {
		*store = _vala_store;
	} else {
		_g_object_unref0 (_vala_store);
	}
	if (folder_name) {
		*folder_name = _vala_folder_name;
	} else {
		_g_free0 (_vala_folder_name);
	}
	return result;
}

static gchar*
mail_move_handler_get_archive_folder_uri_from_folder (MailMoveHandler* self,
                                                      CamelFolder* folder)
{
	CamelStore* store = NULL;
	CamelStore* _tmp0_;
	CamelStore* _tmp23_;
	gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (folder != NULL, NULL);
	_tmp0_ = camel_folder_get_parent_store (folder);
	store = G_TYPE_CHECK_INSTANCE_CAST (_tmp0_, camel_store_get_type (), CamelStore);
	if (G_TYPE_CHECK_INSTANCE_TYPE (folder, camel_vee_folder_get_type ())) {
		CamelVeeFolder* vee_folder = NULL;
		CamelVeeFolder* _tmp1_;
		CamelFolder* orig_folder = NULL;
		_tmp1_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (folder, camel_vee_folder_get_type (), CamelVeeFolder));
		vee_folder = _tmp1_;
		store = NULL;
		orig_folder = NULL;
		{
			GeeArrayList* _message_list = NULL;
			GeeArrayList* _tmp2_;
			gint _message_size = 0;
			GeeArrayList* _tmp3_;
			gint _tmp4_;
			gint _tmp5_;
			gint _message_index = 0;
			_tmp2_ = self->priv->moved_messages;
			_message_list = _tmp2_;
			_tmp3_ = _message_list;
			_tmp4_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp3_);
			_tmp5_ = _tmp4_;
			_message_size = _tmp5_;
			_message_index = -1;
			while (TRUE) {
				gint _tmp6_;
				gint _tmp7_;
				CamelMessageInfo* message = NULL;
				GeeArrayList* _tmp8_;
				gpointer _tmp9_;
				CamelVeeFolder* _tmp10_;
				CamelMessageInfo* _tmp11_;
				const gchar* _tmp12_;
				const gchar* _tmp13_;
				CamelFolder* _tmp14_;
				CamelFolder* _tmp15_;
				_message_index = _message_index + 1;
				_tmp6_ = _message_index;
				_tmp7_ = _message_size;
				if (!(_tmp6_ < _tmp7_)) {
					break;
				}
				_tmp8_ = _message_list;
				_tmp9_ = gee_abstract_list_get ((GeeAbstractList*) _tmp8_, _message_index);
				message = (CamelMessageInfo*) _tmp9_;
				_tmp10_ = vee_folder;
				_tmp11_ = message;
				_tmp12_ = camel_message_info_get_uid (_tmp11_);
				_tmp13_ = _tmp12_;
				_tmp14_ = camel_vee_folder_get_vee_uid_folder (_tmp10_, _tmp13_);
				orig_folder = _tmp14_;
				_tmp15_ = orig_folder;
				if (_tmp15_ != NULL) {
					gboolean _tmp16_ = FALSE;
					CamelStore* _tmp17_;
					CamelFolder* _tmp21_;
					CamelStore* _tmp22_;
					_tmp17_ = store;
					if (_tmp17_ != NULL) {
						CamelFolder* _tmp18_;
						CamelStore* _tmp19_;
						CamelStore* _tmp20_;
						_tmp18_ = orig_folder;
						_tmp19_ = camel_folder_get_parent_store (_tmp18_);
						_tmp20_ = store;
						_tmp16_ = _tmp19_ != _tmp20_;
					} else {
						_tmp16_ = FALSE;
					}
					if (_tmp16_) {
						store = NULL;
						break;
					}
					_tmp21_ = orig_folder;
					_tmp22_ = camel_folder_get_parent_store (_tmp21_);
					store = G_TYPE_CHECK_INSTANCE_CAST (_tmp22_, camel_store_get_type (), CamelStore);
				}
			}
		}
		_g_object_unref0 (vee_folder);
	}
	_tmp23_ = store;
	if (_tmp23_ != NULL) {
		MailBackendSession* _tmp24_;
		CamelStore* _tmp25_;
		gchar* _tmp26_;
		_tmp24_ = mail_backend_session_get_default ();
		_tmp25_ = store;
		_tmp26_ = mail_backend_session_get_archive_folder_uri_for_service (_tmp24_, (CamelService*) _tmp25_);
		result = _tmp26_;
		return result;
	}
	result = NULL;
	return result;
}

static void
mail_move_handler_undo_last_move_data_free (gpointer _data)
{
	MailMoveHandlerUndoLastMoveData* _data_;
	_data_ = _data;
	_mail_move_handler_unref0 (_data_->self);
	g_slice_free (MailMoveHandlerUndoLastMoveData, _data_);
}

void
mail_move_handler_undo_last_move (MailMoveHandler* self,
                                  GAsyncReadyCallback _callback_,
                                  gpointer _user_data_)
{
	MailMoveHandlerUndoLastMoveData* _data_;
	MailMoveHandler* _tmp0_;
	g_return_if_fail (self != NULL);
	_data_ = g_slice_new0 (MailMoveHandlerUndoLastMoveData);
	_data_->_async_result = g_task_new (NULL, NULL, _callback_, _user_data_);
	g_task_set_task_data (_data_->_async_result, _data_, mail_move_handler_undo_last_move_data_free);
	_tmp0_ = _mail_move_handler_ref0 (self);
	_data_->self = _tmp0_;
	mail_move_handler_undo_last_move_co (_data_);
}

void
mail_move_handler_undo_last_move_finish (MailMoveHandler* self,
                                         GAsyncResult* _res_)
{
	MailMoveHandlerUndoLastMoveData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
}

static gboolean
mail_move_handler_undo_last_move_co (MailMoveHandlerUndoLastMoveData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	if (_data_->self->priv->move_type == MAIL_MOVE_HANDLER_MOVE_TYPE_TRASH) {
		_data_->_tmp0_ = _data_->self->priv->src_folder;
		camel_folder_freeze (_data_->_tmp0_);
		{
			_data_->_tmp1_ = _data_->self->priv->moved_messages;
			_data_->_info_list = _data_->_tmp1_;
			_data_->_tmp2_ = _data_->_info_list;
			_data_->_tmp3_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _data_->_tmp2_);
			_data_->_tmp4_ = _data_->_tmp3_;
			_data_->_info_size = _data_->_tmp4_;
			_data_->_info_index = -1;
			while (TRUE) {
				_data_->_info_index = _data_->_info_index + 1;
				_data_->_tmp5_ = _data_->_info_index;
				_data_->_tmp6_ = _data_->_info_size;
				if (!(_data_->_tmp5_ < _data_->_tmp6_)) {
					break;
				}
				_data_->_tmp7_ = _data_->_info_list;
				_data_->_tmp8_ = gee_abstract_list_get ((GeeAbstractList*) _data_->_tmp7_, _data_->_info_index);
				_data_->_tmp9_ = _g_object_ref0 ((CamelMessageInfo*) _data_->_tmp8_);
				_data_->info = _data_->_tmp9_;
				_data_->_tmp10_ = _data_->info;
				camel_message_info_set_flags (_data_->_tmp10_, (guint32) CAMEL_MESSAGE_DELETED, (guint32) 0);
				_g_object_unref0 (_data_->info);
			}
		}
		_data_->_tmp11_ = _data_->self->priv->src_folder;
		camel_folder_thaw (_data_->_tmp11_);
	}
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (!g_task_get_completed (_data_->_async_result)) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}

void
mail_move_handler_expire_undo (MailMoveHandler* self)
{
	g_return_if_fail (self != NULL);
	if (self->priv->timeout_id != ((guint) 0)) {
		g_source_remove (self->priv->timeout_id);
		self->priv->timeout_id = (guint) 0;
	}
}

static void
mail_move_handler_collect_thread_messages (MailMoveHandler* self,
                                           CamelFolderThreadNode* thread)
{
	GeeArrayList* _tmp0_;
	CamelMessageInfo* _tmp1_;
	CamelFolderThreadNode* child = NULL;
	CamelFolderThreadNode* _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (thread != NULL);
	_tmp0_ = self->priv->moved_messages;
	_tmp1_ = thread->message;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp0_, _tmp1_);
	_tmp2_ = thread->child;
	child = (CamelFolderThreadNode*) _tmp2_;
	while (TRUE) {
		CamelFolderThreadNode* _tmp3_;
		CamelFolderThreadNode* _tmp4_;
		CamelFolderThreadNode* _tmp5_;
		CamelFolderThreadNode* _tmp6_;
		_tmp3_ = child;
		if (!(_tmp3_ != NULL)) {
			break;
		}
		_tmp4_ = child;
		mail_move_handler_collect_thread_messages (self, _tmp4_);
		_tmp5_ = child;
		_tmp6_ = _tmp5_->next;
		child = (CamelFolderThreadNode*) _tmp6_;
	}
}

MailMoveHandler*
mail_move_handler_construct (GType object_type)
{
	MailMoveHandler* self = NULL;
	self = (MailMoveHandler*) g_type_create_instance (object_type);
	return self;
}

MailMoveHandler*
mail_move_handler_new (void)
{
	return mail_move_handler_construct (MAIL_TYPE_MOVE_HANDLER);
}

static void
mail_value_move_handler_init (GValue* value)
{
	value->data[0].v_pointer = NULL;
}

static void
mail_value_move_handler_free_value (GValue* value)
{
	if (value->data[0].v_pointer) {
		mail_move_handler_unref (value->data[0].v_pointer);
	}
}

static void
mail_value_move_handler_copy_value (const GValue* src_value,
                                    GValue* dest_value)
{
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = mail_move_handler_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}

static gpointer
mail_value_move_handler_peek_pointer (const GValue* value)
{
	return value->data[0].v_pointer;
}

static gchar*
mail_value_move_handler_collect_value (GValue* value,
                                       guint n_collect_values,
                                       GTypeCValue* collect_values,
                                       guint collect_flags)
{
	if (collect_values[0].v_pointer) {
		MailMoveHandler * object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = mail_move_handler_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}

static gchar*
mail_value_move_handler_lcopy_value (const GValue* value,
                                     guint n_collect_values,
                                     GTypeCValue* collect_values,
                                     guint collect_flags)
{
	MailMoveHandler ** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = mail_move_handler_ref (value->data[0].v_pointer);
	}
	return NULL;
}

GParamSpec*
mail_param_spec_move_handler (const gchar* name,
                              const gchar* nick,
                              const gchar* blurb,
                              GType object_type,
                              GParamFlags flags)
{
	MailParamSpecMoveHandler* spec;
	g_return_val_if_fail (g_type_is_a (object_type, MAIL_TYPE_MOVE_HANDLER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}

gpointer
mail_value_get_move_handler (const GValue* value)
{
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, MAIL_TYPE_MOVE_HANDLER), NULL);
	return value->data[0].v_pointer;
}

void
mail_value_set_move_handler (GValue* value,
                             gpointer v_object)
{
	MailMoveHandler * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, MAIL_TYPE_MOVE_HANDLER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, MAIL_TYPE_MOVE_HANDLER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		mail_move_handler_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		mail_move_handler_unref (old);
	}
}

void
mail_value_take_move_handler (GValue* value,
                              gpointer v_object)
{
	MailMoveHandler * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, MAIL_TYPE_MOVE_HANDLER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, MAIL_TYPE_MOVE_HANDLER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		mail_move_handler_unref (old);
	}
}

static void
mail_move_handler_class_init (MailMoveHandlerClass * klass,
                              gpointer klass_data)
{
	mail_move_handler_parent_class = g_type_class_peek_parent (klass);
	((MailMoveHandlerClass *) klass)->finalize = mail_move_handler_finalize;
	g_type_class_adjust_private_offset (klass, &MailMoveHandler_private_offset);
}

static void
mail_move_handler_instance_init (MailMoveHandler * self,
                                 gpointer klass)
{
	self->priv = mail_move_handler_get_instance_private (self);
	self->priv->timeout_id = (guint) 0;
	self->ref_count = 1;
}

static void
mail_move_handler_finalize (MailMoveHandler * obj)
{
	MailMoveHandler * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, MAIL_TYPE_MOVE_HANDLER, MailMoveHandler);
	g_signal_handlers_destroy (self);
	_g_object_unref0 (self->priv->src_folder);
	_g_object_unref0 (self->priv->dst_folder);
	_g_object_unref0 (self->priv->moved_messages);
}

static GType
mail_move_handler_get_type_once (void)
{
	static const GTypeValueTable g_define_type_value_table = { mail_value_move_handler_init, mail_value_move_handler_free_value, mail_value_move_handler_copy_value, mail_value_move_handler_peek_pointer, "p", mail_value_move_handler_collect_value, "p", mail_value_move_handler_lcopy_value };
	static const GTypeInfo g_define_type_info = { sizeof (MailMoveHandlerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) mail_move_handler_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MailMoveHandler), 0, (GInstanceInitFunc) mail_move_handler_instance_init, &g_define_type_value_table };
	static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
	GType mail_move_handler_type_id;
	mail_move_handler_type_id = g_type_register_fundamental (g_type_fundamental_next (), "MailMoveHandler", &g_define_type_info, &g_define_type_fundamental_info, 0);
	MailMoveHandler_private_offset = g_type_add_instance_private (mail_move_handler_type_id, sizeof (MailMoveHandlerPrivate));
	return mail_move_handler_type_id;
}

GType
mail_move_handler_get_type (void)
{
	static volatile gsize mail_move_handler_type_id__once = 0;
	if (g_once_init_enter (&mail_move_handler_type_id__once)) {
		GType mail_move_handler_type_id;
		mail_move_handler_type_id = mail_move_handler_get_type_once ();
		g_once_init_leave (&mail_move_handler_type_id__once, mail_move_handler_type_id);
	}
	return mail_move_handler_type_id__once;
}

gpointer
mail_move_handler_ref (gpointer instance)
{
	MailMoveHandler * self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}

void
mail_move_handler_unref (gpointer instance)
{
	MailMoveHandler * self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		MAIL_MOVE_HANDLER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}

