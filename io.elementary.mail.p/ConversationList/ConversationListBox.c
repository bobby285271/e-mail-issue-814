/* ConversationListBox.c generated by valac 0.56.3, the Vala compiler
 * generated from ConversationListBox.vala, do not modify */

/* -*- Mode: vala; indent-tabs-mode: nil; tab-width: 4 -*-*/
/*-
 * Copyright (c) 2017 elementary LLC. (https://elementary.io)
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 *
 * Authored by: Corentin NoÃ«l <corentin@elementary.io>
 */

#include <gtk/gtk.h>
#include <glib-object.h>
#include <glib.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <camel/camel.h>
#include <gio/gio.h>
#include <gdk/gdk.h>
#include <glib/gi18n-lib.h>
#include <granite.h>

#define MAIL_CONVERSATION_LIST_BOX_MARK_READ_TIMEOUT_SECONDS 5
#define MAIL_MAIN_WINDOW_ACTION_GROUP_PREFIX "win"
#define MAIL_MAIN_WINDOW_ACTION_PREFIX MAIL_MAIN_WINDOW_ACTION_GROUP_PREFIX "."
#define MAIL_MAIN_WINDOW_ACTION_MOVE_TO_TRASH "trash"
#define MAIL_MAIN_WINDOW_ACTION_MARK_UNREAD "mark-unread"
#define MAIL_MAIN_WINDOW_ACTION_MARK_READ "mark-read"
#define MAIL_MAIN_WINDOW_ACTION_MARK_STAR "mark-star"
#define MAIL_MAIN_WINDOW_ACTION_MARK_UNSTAR "mark-unstar"
#if !defined(VALA_EXTERN)
#if defined(_MSC_VER)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define TYPE_VIRTUALIZING_LIST_BOX (virtualizing_list_box_get_type ())
#define VIRTUALIZING_LIST_BOX(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_VIRTUALIZING_LIST_BOX, VirtualizingListBox))
#define VIRTUALIZING_LIST_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_VIRTUALIZING_LIST_BOX, VirtualizingListBoxClass))
#define IS_VIRTUALIZING_LIST_BOX(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_VIRTUALIZING_LIST_BOX))
#define IS_VIRTUALIZING_LIST_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_VIRTUALIZING_LIST_BOX))
#define VIRTUALIZING_LIST_BOX_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_VIRTUALIZING_LIST_BOX, VirtualizingListBoxClass))

typedef struct _VirtualizingListBox VirtualizingListBox;
typedef struct _VirtualizingListBoxClass VirtualizingListBoxClass;
typedef struct _VirtualizingListBoxPrivate VirtualizingListBoxPrivate;

#define TYPE_VIRTUALIZING_LIST_BOX_ROW (virtualizing_list_box_row_get_type ())
#define VIRTUALIZING_LIST_BOX_ROW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_VIRTUALIZING_LIST_BOX_ROW, VirtualizingListBoxRow))
#define VIRTUALIZING_LIST_BOX_ROW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_VIRTUALIZING_LIST_BOX_ROW, VirtualizingListBoxRowClass))
#define IS_VIRTUALIZING_LIST_BOX_ROW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_VIRTUALIZING_LIST_BOX_ROW))
#define IS_VIRTUALIZING_LIST_BOX_ROW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_VIRTUALIZING_LIST_BOX_ROW))
#define VIRTUALIZING_LIST_BOX_ROW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_VIRTUALIZING_LIST_BOX_ROW, VirtualizingListBoxRowClass))

typedef struct _VirtualizingListBoxRow VirtualizingListBoxRow;
typedef struct _VirtualizingListBoxRowClass VirtualizingListBoxRowClass;
typedef VirtualizingListBoxRow* (*VirtualizingListBoxRowFactoryMethod) (GObject* item, VirtualizingListBoxRow* old_widget, gpointer user_data);

#define MAIL_TYPE_CONVERSATION_LIST_BOX (mail_conversation_list_box_get_type ())
#define MAIL_CONVERSATION_LIST_BOX(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAIL_TYPE_CONVERSATION_LIST_BOX, MailConversationListBox))
#define MAIL_CONVERSATION_LIST_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MAIL_TYPE_CONVERSATION_LIST_BOX, MailConversationListBoxClass))
#define MAIL_IS_CONVERSATION_LIST_BOX(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAIL_TYPE_CONVERSATION_LIST_BOX))
#define MAIL_IS_CONVERSATION_LIST_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MAIL_TYPE_CONVERSATION_LIST_BOX))
#define MAIL_CONVERSATION_LIST_BOX_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MAIL_TYPE_CONVERSATION_LIST_BOX, MailConversationListBoxClass))

typedef struct _MailConversationListBox MailConversationListBox;
typedef struct _MailConversationListBoxClass MailConversationListBoxClass;
typedef struct _MailConversationListBoxPrivate MailConversationListBoxPrivate;

#define MAIL_BACKEND_TYPE_ACCOUNT (mail_backend_account_get_type ())
#define MAIL_BACKEND_ACCOUNT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAIL_BACKEND_TYPE_ACCOUNT, MailBackendAccount))
#define MAIL_BACKEND_ACCOUNT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MAIL_BACKEND_TYPE_ACCOUNT, MailBackendAccountClass))
#define MAIL_BACKEND_IS_ACCOUNT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAIL_BACKEND_TYPE_ACCOUNT))
#define MAIL_BACKEND_IS_ACCOUNT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MAIL_BACKEND_TYPE_ACCOUNT))
#define MAIL_BACKEND_ACCOUNT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MAIL_BACKEND_TYPE_ACCOUNT, MailBackendAccountClass))

typedef struct _MailBackendAccount MailBackendAccount;
typedef struct _MailBackendAccountClass MailBackendAccountClass;

#define MAIL_TYPE_CONVERSATION_ITEM_MODEL (mail_conversation_item_model_get_type ())
#define MAIL_CONVERSATION_ITEM_MODEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAIL_TYPE_CONVERSATION_ITEM_MODEL, MailConversationItemModel))
#define MAIL_CONVERSATION_ITEM_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MAIL_TYPE_CONVERSATION_ITEM_MODEL, MailConversationItemModelClass))
#define MAIL_IS_CONVERSATION_ITEM_MODEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAIL_TYPE_CONVERSATION_ITEM_MODEL))
#define MAIL_IS_CONVERSATION_ITEM_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MAIL_TYPE_CONVERSATION_ITEM_MODEL))
#define MAIL_CONVERSATION_ITEM_MODEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MAIL_TYPE_CONVERSATION_ITEM_MODEL, MailConversationItemModelClass))

typedef struct _MailConversationItemModel MailConversationItemModel;
typedef struct _MailConversationItemModelClass MailConversationItemModelClass;

#define TYPE_VIRTUALIZING_LIST_BOX_MODEL (virtualizing_list_box_model_get_type ())
#define VIRTUALIZING_LIST_BOX_MODEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_VIRTUALIZING_LIST_BOX_MODEL, VirtualizingListBoxModel))
#define VIRTUALIZING_LIST_BOX_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_VIRTUALIZING_LIST_BOX_MODEL, VirtualizingListBoxModelClass))
#define IS_VIRTUALIZING_LIST_BOX_MODEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_VIRTUALIZING_LIST_BOX_MODEL))
#define IS_VIRTUALIZING_LIST_BOX_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_VIRTUALIZING_LIST_BOX_MODEL))
#define VIRTUALIZING_LIST_BOX_MODEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_VIRTUALIZING_LIST_BOX_MODEL, VirtualizingListBoxModelClass))

typedef struct _VirtualizingListBoxModel VirtualizingListBoxModel;
typedef struct _VirtualizingListBoxModelClass VirtualizingListBoxModelClass;

#define MAIL_TYPE_CONVERSATION_LIST_STORE (mail_conversation_list_store_get_type ())
#define MAIL_CONVERSATION_LIST_STORE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAIL_TYPE_CONVERSATION_LIST_STORE, MailConversationListStore))
#define MAIL_CONVERSATION_LIST_STORE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MAIL_TYPE_CONVERSATION_LIST_STORE, MailConversationListStoreClass))
#define MAIL_IS_CONVERSATION_LIST_STORE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAIL_TYPE_CONVERSATION_LIST_STORE))
#define MAIL_IS_CONVERSATION_LIST_STORE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MAIL_TYPE_CONVERSATION_LIST_STORE))
#define MAIL_CONVERSATION_LIST_STORE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MAIL_TYPE_CONVERSATION_LIST_STORE, MailConversationListStoreClass))

typedef struct _MailConversationListStore MailConversationListStore;
typedef struct _MailConversationListStoreClass MailConversationListStoreClass;

#define MAIL_TYPE_MOVE_HANDLER (mail_move_handler_get_type ())
#define MAIL_MOVE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAIL_TYPE_MOVE_HANDLER, MailMoveHandler))
#define MAIL_MOVE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MAIL_TYPE_MOVE_HANDLER, MailMoveHandlerClass))
#define MAIL_IS_MOVE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAIL_TYPE_MOVE_HANDLER))
#define MAIL_IS_MOVE_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MAIL_TYPE_MOVE_HANDLER))
#define MAIL_MOVE_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MAIL_TYPE_MOVE_HANDLER, MailMoveHandlerClass))

typedef struct _MailMoveHandler MailMoveHandler;
typedef struct _MailMoveHandlerClass MailMoveHandlerClass;
enum  {
	MAIL_CONVERSATION_LIST_BOX_0_PROPERTY,
	MAIL_CONVERSATION_LIST_BOX_FOLDER_FULL_NAME_PER_ACCOUNT_PROPERTY,
	MAIL_CONVERSATION_LIST_BOX_FOLDERS_PROPERTY,
	MAIL_CONVERSATION_LIST_BOX_FOLDER_INFO_FLAGS_PROPERTY,
	MAIL_CONVERSATION_LIST_BOX_NUM_PROPERTIES
};
static GParamSpec* mail_conversation_list_box_properties[MAIL_CONVERSATION_LIST_BOX_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _mail_move_handler_unref0(var) ((var == NULL) ? NULL : (var = (mail_move_handler_unref (var), NULL)))
typedef struct _Block20Data Block20Data;
#define _camel_folder_thread_messages_unref0(var) ((var == NULL) ? NULL : (var = (camel_folder_thread_messages_unref (var), NULL)))
#define _g_ptr_array_unref0(var) ((var == NULL) ? NULL : (var = (g_ptr_array_unref (var), NULL)))
#define __vala_CamelFolderInfo_free0(var) ((var == NULL) ? NULL : (var = (_vala_CamelFolderInfo_free (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _MailConversationListBoxLoadFolderData MailConversationListBoxLoadFolderData;
typedef struct _MailConversationListBoxRefreshFolderData MailConversationListBoxRefreshFolderData;
typedef struct _Block21Data Block21Data;
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))
typedef struct _MailConversationListBoxSearchData MailConversationListBoxSearchData;
typedef struct _MailConversationListBoxArchiveSelectedMessagesData MailConversationListBoxArchiveSelectedMessagesData;

#define MAIL_TYPE_CONVERSATION_LIST_ITEM (mail_conversation_list_item_get_type ())
#define MAIL_CONVERSATION_LIST_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAIL_TYPE_CONVERSATION_LIST_ITEM, MailConversationListItem))
#define MAIL_CONVERSATION_LIST_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MAIL_TYPE_CONVERSATION_LIST_ITEM, MailConversationListItemClass))
#define MAIL_IS_CONVERSATION_LIST_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAIL_TYPE_CONVERSATION_LIST_ITEM))
#define MAIL_IS_CONVERSATION_LIST_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MAIL_TYPE_CONVERSATION_LIST_ITEM))
#define MAIL_CONVERSATION_LIST_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MAIL_TYPE_CONVERSATION_LIST_ITEM, MailConversationListItemClass))

typedef struct _MailConversationListItem MailConversationListItem;
typedef struct _MailConversationListItemClass MailConversationListItemClass;
typedef gboolean (*MailConversationListStoreRowVisibilityFunc) (GObject* row, gpointer user_data);
typedef struct _Block22Data Block22Data;
enum  {
	MAIL_CONVERSATION_LIST_BOX_CONVERSATION_SELECTED_SIGNAL,
	MAIL_CONVERSATION_LIST_BOX_CONVERSATION_FOCUSED_SIGNAL,
	MAIL_CONVERSATION_LIST_BOX_NUM_SIGNALS
};
static guint mail_conversation_list_box_signals[MAIL_CONVERSATION_LIST_BOX_NUM_SIGNALS] = {0};

struct _VirtualizingListBox {
	GtkContainer parent_instance;
	VirtualizingListBoxPrivate * priv;
	VirtualizingListBoxRowFactoryMethod factory_func;
	gpointer factory_func_target;
	GDestroyNotify factory_func_target_destroy_notify;
};

struct _VirtualizingListBoxClass {
	GtkContainerClass parent_class;
};

struct _MailConversationListBox {
	VirtualizingListBox parent_instance;
	MailConversationListBoxPrivate * priv;
};

struct _MailConversationListBoxClass {
	VirtualizingListBoxClass parent_class;
};

struct _MailConversationListBoxPrivate {
	GeeMap* _folder_full_name_per_account;
	GeeHashMap* _folders;
	GeeHashMap* _folder_info_flags;
	GCancellable* cancellable;
	GeeHashMap* threads;
	GRecMutex __lock_threads;
	gchar* current_search_query;
	gboolean current_search_hide_read;
	gboolean current_search_hide_unstarred;
	GeeHashMap* conversations;
	GRecMutex __lock_conversations;
	MailConversationListStore* list_store;
	MailMoveHandler* move_handler;
	guint mark_read_timeout_id;
	GRecMutex __lock_folder_full_name_per_account;
	GRecMutex __lock_folders;
};

struct _Block20Data {
	int _ref_count_;
	MailConversationListBox* self;
	MailBackendAccount* current_account;
};

struct _MailConversationListBoxLoadFolderData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	MailConversationListBox* self;
	GeeMap* folder_full_name_per_account;
	GeeMap* _tmp0_;
	GeeMap* _tmp1_;
	GCancellable* _tmp2_;
	GCancellable* _tmp3_;
	guint previous_items;
	MailConversationListStore* _tmp4_;
	GeeHashMap* _tmp5_;
	GeeHashMap* _tmp6_;
	GeeHashMap* _tmp7_;
	GeeHashMap* _tmp8_;
	GeeHashMap* _tmp9_;
	GeeHashMap* _tmp10_;
	MailConversationListStore* _tmp11_;
	MailConversationListStore* _tmp12_;
	GCancellable* _tmp13_;
	GeeMap* _tmp14_;
	GeeIterator* _folder_full_name_entry_it;
	GeeMap* _tmp15_;
	GeeIterator* _tmp16_;
	Block20Data* _data20_;
	GeeIterator* _tmp17_;
	GeeMapEntry* folder_full_name_entry;
	GeeIterator* _tmp18_;
	gpointer _tmp19_;
	GeeMapEntry* _tmp20_;
	gconstpointer _tmp21_;
	gconstpointer _tmp22_;
	MailBackendAccount* _tmp23_;
	gchar* current_full_name;
	GeeMapEntry* _tmp24_;
	gconstpointer _tmp25_;
	gconstpointer _tmp26_;
	gchar* _tmp27_;
	const gchar* _tmp28_;
	CamelStore* camel_store;
	MailBackendAccount* _tmp29_;
	CamelService* _tmp30_;
	CamelService* _tmp31_;
	CamelStore* _tmp32_;
	CamelFolder* folder;
	CamelStore* _tmp33_;
	const gchar* _tmp34_;
	GCancellable* _tmp35_;
	CamelFolder* _tmp36_;
	GeeHashMap* _tmp37_;
	MailBackendAccount* _tmp38_;
	CamelService* _tmp39_;
	CamelService* _tmp40_;
	const gchar* _tmp41_;
	const gchar* _tmp42_;
	CamelFolder* _tmp43_;
	CamelFolderInfo* _tmp44_;
	CamelStore* _tmp45_;
	CamelFolder* _tmp46_;
	const gchar* _tmp47_;
	const gchar* _tmp48_;
	CamelFolderInfo* _tmp49_;
	CamelFolderInfoFlags info_flags;
	MailBackendAccount* _tmp50_;
	CamelService* _tmp51_;
	CamelService* _tmp52_;
	GeeHashMap* _tmp53_;
	MailBackendAccount* _tmp54_;
	CamelService* _tmp55_;
	CamelService* _tmp56_;
	const gchar* _tmp57_;
	const gchar* _tmp58_;
	CamelFolder* _tmp59_;
	GPtrArray* search_result_uids;
	MailBackendAccount* _tmp60_;
	CamelService* _tmp61_;
	CamelService* _tmp62_;
	const gchar* _tmp63_;
	const gchar* _tmp64_;
	GPtrArray* _tmp65_;
	GPtrArray* _tmp66_;
	CamelFolderThread* thread;
	CamelFolder* _tmp67_;
	GPtrArray* _tmp68_;
	CamelFolderThread* _tmp69_;
	GeeHashMap* _tmp70_;
	MailBackendAccount* _tmp71_;
	CamelService* _tmp72_;
	CamelService* _tmp73_;
	const gchar* _tmp74_;
	const gchar* _tmp75_;
	CamelFolderThread* _tmp76_;
	CamelFolderThreadNode* child;
	CamelFolderThread* _tmp77_;
	CamelFolderThreadNode* _tmp78_;
	CamelFolderThreadNode* _tmp79_;
	GCancellable* _tmp80_;
	GeeHashMap* _tmp81_;
	MailBackendAccount* _tmp82_;
	CamelService* _tmp83_;
	CamelService* _tmp84_;
	const gchar* _tmp85_;
	const gchar* _tmp86_;
	gpointer _tmp87_;
	CamelFolderThreadNode* _tmp88_;
	CamelFolderThread* _tmp89_;
	MailBackendAccount* _tmp90_;
	CamelService* _tmp91_;
	CamelService* _tmp92_;
	const gchar* _tmp93_;
	const gchar* _tmp94_;
	CamelFolderThreadNode* _tmp95_;
	CamelFolderThreadNode* _tmp96_;
	GError* e;
	GError* _tmp97_;
	GError* _tmp98_;
	const gchar* _tmp99_;
	GeeHashMap* _tmp100_;
	GeeHashMap* _tmp101_;
	GeeHashMap* _tmp102_;
	GeeMap* _tmp103_;
	GeeHashMap* _tmp104_;
	GeeHashMap* _tmp105_;
	GeeHashMap* _tmp106_;
	GeeHashMap* _tmp107_;
	GeeHashMap* _tmp108_;
	GeeHashMap* _tmp109_;
	MailConversationListStore* _tmp110_;
	MailConversationListStore* _tmp111_;
	GError* _inner_error0_;
};

struct _MailConversationListBoxRefreshFolderData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	MailConversationListBox* self;
	GCancellable* cancellable;
	GeeHashMap* _tmp0_;
	GeeIterator* _folder_it;
	GeeHashMap* _tmp1_;
	GeeCollection* _tmp2_;
	GeeCollection* _tmp3_;
	GeeCollection* _tmp4_;
	GeeIterator* _tmp5_;
	GeeIterator* _tmp6_;
	GeeIterator* _tmp7_;
	CamelFolder* folder;
	GeeIterator* _tmp8_;
	gpointer _tmp9_;
	CamelFolder* _tmp10_;
	GError* e;
	CamelFolder* _tmp11_;
	const gchar* _tmp12_;
	const gchar* _tmp13_;
	CamelFolder* _tmp14_;
	CamelStore* _tmp15_;
	CamelStore* _tmp16_;
	const gchar* _tmp17_;
	const gchar* _tmp18_;
	GError* _tmp19_;
	const gchar* _tmp20_;
	GeeHashMap* _tmp21_;
	GError* _inner_error0_;
};

struct _Block21Data {
	int _ref_count_;
	MailConversationListBox* self;
	gint removed;
};

struct _MailConversationListBoxSearchData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	MailConversationListBox* self;
	gchar* query;
	gboolean hide_read;
	gboolean hide_unstarred;
	gchar* _tmp0_;
	GeeMap* _tmp1_;
};

struct _MailConversationListBoxArchiveSelectedMessagesData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	MailConversationListBox* self;
	gint result;
	GeeHashMap* archive_threads;
	GeeHashMap* _tmp0_;
	GeeHashSet* selected_rows;
	GeeHashSet* _tmp1_;
	gint selected_rows_start_index;
	MailConversationListStore* _tmp2_;
	GeeHashSet* _tmp3_;
	gint _tmp4_;
	gpointer* _tmp5_;
	GObject** _tmp6_;
	gint _tmp6__length1;
	GObject* _tmp7_;
	gint _tmp8_;
	GeeIterator* _selected_row_it;
	GeeHashSet* _tmp9_;
	GeeIterator* _tmp10_;
	GeeIterator* _tmp11_;
	GObject* selected_row;
	GeeIterator* _tmp12_;
	gpointer _tmp13_;
	MailConversationItemModel* selected_item_model;
	GObject* _tmp14_;
	MailConversationItemModel* _tmp15_;
	GeeHashMap* _tmp16_;
	MailConversationItemModel* _tmp17_;
	const gchar* _tmp18_;
	const gchar* _tmp19_;
	gpointer _tmp20_;
	GeeArrayList* _tmp21_;
	gboolean _tmp22_;
	GeeHashMap* _tmp23_;
	MailConversationItemModel* _tmp24_;
	const gchar* _tmp25_;
	const gchar* _tmp26_;
	GeeArrayList* _tmp27_;
	GeeArrayList* _tmp28_;
	GeeHashMap* _tmp29_;
	MailConversationItemModel* _tmp30_;
	const gchar* _tmp31_;
	const gchar* _tmp32_;
	gpointer _tmp33_;
	GeeArrayList* _tmp34_;
	MailConversationItemModel* _tmp35_;
	CamelFolderThreadNode* _tmp36_;
	CamelFolderThreadNode* _tmp37_;
	gint archived;
	GeeIterator* _service_uid_it;
	GeeHashMap* _tmp38_;
	GeeSet* _tmp39_;
	GeeSet* _tmp40_;
	GeeSet* _tmp41_;
	GeeIterator* _tmp42_;
	GeeIterator* _tmp43_;
	GeeIterator* _tmp44_;
	gchar* service_uid;
	GeeIterator* _tmp45_;
	gpointer _tmp46_;
	MailMoveHandler* _tmp47_;
	GeeHashMap* _tmp48_;
	const gchar* _tmp49_;
	gpointer _tmp50_;
	CamelFolder* _tmp51_;
	GeeHashMap* _tmp52_;
	const gchar* _tmp53_;
	gpointer _tmp54_;
	GeeArrayList* _tmp55_;
	GeeIterator* _vala1__service_uid_it;
	GeeHashMap* _tmp56_;
	GeeSet* _tmp57_;
	GeeSet* _tmp58_;
	GeeSet* _tmp59_;
	GeeIterator* _tmp60_;
	GeeIterator* _tmp61_;
	GeeIterator* _tmp62_;
	gchar* _vala1_service_uid;
	GeeIterator* _tmp63_;
	gpointer _tmp64_;
	GeeArrayList* threads;
	GeeHashMap* _tmp65_;
	const gchar* _tmp66_;
	gpointer _tmp67_;
	GeeArrayList* _thread_list;
	GeeArrayList* _tmp68_;
	gint _thread_size;
	GeeArrayList* _tmp69_;
	gint _tmp70_;
	gint _tmp71_;
	gint _thread_index;
	gint _tmp72_;
	gint _tmp73_;
	CamelFolderThreadNode* thread;
	GeeArrayList* _tmp74_;
	gpointer _tmp75_;
	const gchar* uid;
	CamelFolderThreadNode* _tmp76_;
	CamelMessageInfo* _tmp77_;
	const gchar* _tmp78_;
	const gchar* _tmp79_;
	MailConversationItemModel* item;
	GeeHashMap* _tmp80_;
	const gchar* _tmp81_;
	gpointer _tmp82_;
	MailConversationItemModel* _tmp83_;
	GeeHashMap* _tmp84_;
	const gchar* _tmp85_;
	MailConversationListStore* _tmp86_;
	MailConversationItemModel* _tmp87_;
	MailConversationListStore* _tmp88_;
	MailConversationListStore* _tmp89_;
};

struct _Block22Data {
	int _ref_count_;
	MailConversationListBox* self;
	GObject* row;
};

static gint MailConversationListBox_private_offset;
static gpointer mail_conversation_list_box_parent_class = NULL;

VALA_EXTERN GType virtualizing_list_box_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (VirtualizingListBox, g_object_unref)
VALA_EXTERN GType virtualizing_list_box_row_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (VirtualizingListBoxRow, g_object_unref)
VALA_EXTERN GType mail_conversation_list_box_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (MailConversationListBox, g_object_unref)
VALA_EXTERN GType mail_backend_account_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (MailBackendAccount, g_object_unref)
VALA_EXTERN GType mail_conversation_item_model_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (MailConversationItemModel, g_object_unref)
VALA_EXTERN GType virtualizing_list_box_model_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (VirtualizingListBoxModel, g_object_unref)
VALA_EXTERN GType mail_conversation_list_store_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (MailConversationListStore, g_object_unref)
VALA_EXTERN gpointer mail_move_handler_ref (gpointer instance);
VALA_EXTERN void mail_move_handler_unref (gpointer instance);
VALA_EXTERN GParamSpec* mail_param_spec_move_handler (const gchar* name,
                                          const gchar* nick,
                                          const gchar* blurb,
                                          GType object_type,
                                          GParamFlags flags);
VALA_EXTERN void mail_value_set_move_handler (GValue* value,
                                  gpointer v_object);
VALA_EXTERN void mail_value_take_move_handler (GValue* value,
                                   gpointer v_object);
VALA_EXTERN gpointer mail_value_get_move_handler (const GValue* value);
VALA_EXTERN GType mail_move_handler_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (MailMoveHandler, mail_move_handler_unref)
static void mail_conversation_list_box_set_thread_flag (CamelFolderThreadNode* node,
                                                 CamelMessageFlags flag);
static void mail_conversation_list_box_load_folder_data_free (gpointer _data);
VALA_EXTERN void mail_conversation_list_box_load_folder (MailConversationListBox* self,
                                             GeeMap* folder_full_name_per_account,
                                             GAsyncReadyCallback _callback_,
                                             gpointer _user_data_);
VALA_EXTERN void mail_conversation_list_box_load_folder_finish (MailConversationListBox* self,
                                                    GAsyncResult* _res_);
static gboolean mail_conversation_list_box_load_folder_co (MailConversationListBoxLoadFolderData* _data_);
VALA_EXTERN GeeMap* mail_conversation_list_box_get_folder_full_name_per_account (MailConversationListBox* self);
static void mail_conversation_list_box_set_folder_full_name_per_account (MailConversationListBox* self,
                                                                  GeeMap* value);
VALA_EXTERN guint virtualizing_list_box_model_get_n_items (VirtualizingListBoxModel* self);
VALA_EXTERN GeeHashMap* mail_conversation_list_box_get_folders (MailConversationListBox* self);
VALA_EXTERN void mail_conversation_list_store_remove_all (MailConversationListStore* self);
static Block20Data* block20_data_ref (Block20Data* _data20_);
static void block20_data_unref (void * _userdata_);
VALA_EXTERN CamelService* mail_backend_account_get_service (MailBackendAccount* self);
static void mail_conversation_list_box_load_folder_ready (GObject* source_object,
                                                   GAsyncResult* _res_,
                                                   gpointer _user_data_);
VALA_EXTERN CamelFolderInfoFlags mail_utils_get_full_folder_info_flags (CamelService* service,
                                                            CamelFolderInfo* folderinfo);
VALA_EXTERN GeeHashMap* mail_conversation_list_box_get_folder_info_flags (MailConversationListBox* self);
static void _________lambda24_ (Block20Data* _data20_,
                         CamelFolderChangeInfo* change_info);
static void mail_conversation_list_box_folder_changed (MailConversationListBox* self,
                                                CamelFolderChangeInfo* change_info,
                                                const gchar* service_uid,
                                                GCancellable* cancellable);
static void __________lambda24__camel_folder_changed (CamelFolder* _sender,
                                               CamelFolderChangeInfo* changes,
                                               gpointer self);
static GPtrArray* mail_conversation_list_box_get_search_result_uids (MailConversationListBox* self,
                                                              const gchar* service_uid);
static void mail_conversation_list_box_add_conversation_item (MailConversationListBox* self,
                                                       CamelFolderInfoFlags folder_info_flags,
                                                       CamelFolderThreadNode* child,
                                                       CamelFolderThread* thread,
                                                       const gchar* service_uid);
static void _vala_CamelFolderInfo_free (CamelFolderInfo* self);
static void mail_conversation_list_box_refresh_folder_data_free (gpointer _data);
VALA_EXTERN void mail_conversation_list_box_refresh_folder (MailConversationListBox* self,
                                                GCancellable* cancellable,
                                                GAsyncReadyCallback _callback_,
                                                gpointer _user_data_);
VALA_EXTERN void mail_conversation_list_box_refresh_folder_finish (MailConversationListBox* self,
                                                       GAsyncResult* _res_);
static gboolean mail_conversation_list_box_refresh_folder_co (MailConversationListBoxRefreshFolderData* _data_);
static void mail_conversation_list_box_refresh_folder_ready (GObject* source_object,
                                                      GAsyncResult* _res_,
                                                      gpointer _user_data_);
static Block21Data* block21_data_ref (Block21Data* _data21_);
static void block21_data_unref (void * _userdata_);
static void ____lambda25_ (Block21Data* _data21_,
                    const gchar* uid);
VALA_EXTERN void mail_conversation_list_store_remove (MailConversationListStore* self,
                                          MailConversationItemModel* data);
static void _____lambda25__gfunc (gconstpointer data,
                           gpointer self);
VALA_EXTERN gboolean mail_conversation_item_model_is_older_than (MailConversationItemModel* self,
                                                     CamelFolderThreadNode* other_node);
static void _vala_array_add3 (gchar** * array,
                       gint* length,
                       gint* size,
                       gchar* value);
static void _vala_array_add4 (gchar** * array,
                       gint* length,
                       gint* size,
                       gchar* value);
static void _vala_array_add5 (gchar** * array,
                       gint* length,
                       gint* size,
                       gchar* value);
static void mail_conversation_list_box_search_data_free (gpointer _data);
VALA_EXTERN void mail_conversation_list_box_search (MailConversationListBox* self,
                                        const gchar* query,
                                        gboolean hide_read,
                                        gboolean hide_unstarred,
                                        GAsyncReadyCallback _callback_,
                                        gpointer _user_data_);
VALA_EXTERN void mail_conversation_list_box_search_finish (MailConversationListBox* self,
                                               GAsyncResult* _res_);
static gboolean mail_conversation_list_box_search_co (MailConversationListBoxSearchData* _data_);
static void mail_conversation_list_box_search_ready (GObject* source_object,
                                              GAsyncResult* _res_,
                                              gpointer _user_data_);
VALA_EXTERN MailConversationItemModel* mail_conversation_item_model_new (CamelFolderInfoFlags folder_info_flags,
                                                             CamelFolderThreadNode* node,
                                                             CamelFolderThread* thread,
                                                             const gchar* service_uid);
VALA_EXTERN MailConversationItemModel* mail_conversation_item_model_construct (GType object_type,
                                                                   CamelFolderInfoFlags folder_info_flags,
                                                                   CamelFolderThreadNode* node,
                                                                   CamelFolderThread* thread,
                                                                   const gchar* service_uid);
VALA_EXTERN void mail_conversation_list_store_add (MailConversationListStore* self,
                                       MailConversationItemModel* data);
static gboolean mail_conversation_list_box_filter_function (GObject* obj);
VALA_EXTERN gboolean mail_conversation_item_model_get_deleted (MailConversationItemModel* self);
static gint mail_conversation_list_box_thread_sort_function (MailConversationItemModel* item1,
                                                      MailConversationItemModel* item2);
VALA_EXTERN gint64 mail_conversation_item_model_get_timestamp (MailConversationItemModel* self);
VALA_EXTERN void mail_conversation_list_box_mark_read_selected_messages (MailConversationListBox* self);
VALA_EXTERN GeeHashSet* virtualizing_list_box_get_selected_rows (VirtualizingListBox* self);
VALA_EXTERN CamelFolderThreadNode* mail_conversation_item_model_get_node (MailConversationItemModel* self);
VALA_EXTERN void mail_conversation_list_box_mark_star_selected_messages (MailConversationListBox* self);
VALA_EXTERN void mail_conversation_list_box_mark_unread_selected_messages (MailConversationListBox* self);
VALA_EXTERN void mail_conversation_list_box_mark_unstar_selected_messages (MailConversationListBox* self);
static void mail_conversation_list_box_archive_selected_messages_data_free (gpointer _data);
VALA_EXTERN void mail_conversation_list_box_archive_selected_messages (MailConversationListBox* self,
                                                           GAsyncReadyCallback _callback_,
                                                           gpointer _user_data_);
VALA_EXTERN gint mail_conversation_list_box_archive_selected_messages_finish (MailConversationListBox* self,
                                                                  GAsyncResult* _res_);
static gboolean mail_conversation_list_box_archive_selected_messages_co (MailConversationListBoxArchiveSelectedMessagesData* _data_);
VALA_EXTERN gint virtualizing_list_box_model_get_index_of (VirtualizingListBoxModel* self,
                                               GObject* item);
VALA_EXTERN const gchar* mail_conversation_item_model_get_service_uid (MailConversationItemModel* self);
VALA_EXTERN void mail_move_handler_archive_threads (MailMoveHandler* self,
                                        CamelFolder* folder,
                                        GeeArrayList* threads,
                                        GAsyncReadyCallback _callback_,
                                        gpointer _user_data_);
VALA_EXTERN gint mail_move_handler_archive_threads_finish (MailMoveHandler* self,
                                               GAsyncResult* _res_);
static void mail_conversation_list_box_archive_selected_messages_ready (GObject* source_object,
                                                                 GAsyncResult* _res_,
                                                                 gpointer _user_data_);
VALA_EXTERN void virtualizing_list_box_select_row_at_index (VirtualizingListBox* self,
                                                gint index);
VALA_EXTERN gint mail_conversation_list_box_trash_selected_messages (MailConversationListBox* self);
VALA_EXTERN gint mail_move_handler_delete_threads (MailMoveHandler* self,
                                       CamelFolder* folder,
                                       GeeArrayList* threads);
VALA_EXTERN void mail_conversation_list_box_undo_move (MailConversationListBox* self);
VALA_EXTERN void mail_move_handler_undo_last_move (MailMoveHandler* self,
                                       GAsyncReadyCallback _callback_,
                                       gpointer _user_data_);
VALA_EXTERN void mail_move_handler_undo_last_move_finish (MailMoveHandler* self,
                                              GAsyncResult* _res_);
static void __lambda26_ (MailConversationListBox* self,
                  GObject* obj,
                  GAsyncResult* res);
static void ___lambda26__gasync_ready_callback (GObject* source_object,
                                         GAsyncResult* res,
                                         gpointer self);
VALA_EXTERN void mail_conversation_list_box_undo_expired (MailConversationListBox* self);
VALA_EXTERN void mail_move_handler_expire_undo (MailMoveHandler* self);
VALA_EXTERN GType mail_conversation_list_item_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (MailConversationListItem, g_object_unref)
static gboolean mail_conversation_list_box_create_context_menu (MailConversationListBox* self,
                                                         GdkEvent* e,
                                                         MailConversationListItem* row);
VALA_EXTERN GObject* virtualizing_list_box_row_get_model_item (VirtualizingListBoxRow* self);
static void __lambda27_ (MailConversationListBox* self);
static void ___lambda27__gtk_menu_item_activate (GtkMenuItem* _sender,
                                          gpointer self);
VALA_EXTERN gboolean mail_conversation_item_model_get_unread (MailConversationItemModel* self);
static void ___lambda28_ (MailConversationListBox* self);
static void ____lambda28__gtk_menu_item_activate (GtkMenuItem* _sender,
                                           gpointer self);
static void ___lambda29_ (MailConversationListBox* self);
static void ____lambda29__gtk_menu_item_activate (GtkMenuItem* _sender,
                                           gpointer self);
VALA_EXTERN gboolean mail_conversation_item_model_get_flagged (MailConversationItemModel* self);
static void ___lambda30_ (MailConversationListBox* self);
static void ____lambda30__gtk_menu_item_activate (GtkMenuItem* _sender,
                                           gpointer self);
static void ___lambda31_ (MailConversationListBox* self);
static void ____lambda31__gtk_menu_item_activate (GtkMenuItem* _sender,
                                           gpointer self);
VALA_EXTERN MailConversationListBox* mail_conversation_list_box_new (void);
VALA_EXTERN MailConversationListBox* mail_conversation_list_box_construct (GType object_type);
VALA_EXTERN VirtualizingListBox* virtualizing_list_box_new (void);
VALA_EXTERN VirtualizingListBox* virtualizing_list_box_construct (GType object_type);
static void mail_conversation_list_box_set_folders (MailConversationListBox* self,
                                             GeeHashMap* value);
static void mail_conversation_list_box_set_folder_info_flags (MailConversationListBox* self,
                                                       GeeHashMap* value);
static GObject * mail_conversation_list_box_constructor (GType type,
                                                  guint n_construct_properties,
                                                  GObjectConstructParam * construct_properties);
VALA_EXTERN void virtualizing_list_box_set_activate_on_single_click (VirtualizingListBox* self,
                                                         gboolean value);
VALA_EXTERN MailConversationListStore* mail_conversation_list_store_new (void);
VALA_EXTERN MailConversationListStore* mail_conversation_list_store_construct (GType object_type);
VALA_EXTERN void mail_conversation_list_store_set_sort_func (MailConversationListStore* self,
                                                 GCompareDataFunc function,
                                                 gpointer function_target);
static gint _mail_conversation_list_box_thread_sort_function_gcompare_data_func (gconstpointer a,
                                                                          gconstpointer b,
                                                                          gpointer self);
VALA_EXTERN void mail_conversation_list_store_set_filter_func (MailConversationListStore* self,
                                                   MailConversationListStoreRowVisibilityFunc function,
                                                   gpointer function_target);
static gboolean _mail_conversation_list_box_filter_function_mail_conversation_list_store_row_visibility_func (GObject* row,
                                                                                                       gpointer self);
VALA_EXTERN void virtualizing_list_box_set_model (VirtualizingListBox* self,
                                      VirtualizingListBoxModel* value);
VALA_EXTERN MailMoveHandler* mail_move_handler_new (void);
VALA_EXTERN MailMoveHandler* mail_move_handler_construct (GType object_type);
static VirtualizingListBoxRow* _mail_conversation_list_box___lambda32_ (MailConversationListBox* self,
                                                                 GObject* item,
                                                                 VirtualizingListBoxRow* old_widget);
VALA_EXTERN MailConversationListItem* mail_conversation_list_item_new (void);
VALA_EXTERN MailConversationListItem* mail_conversation_list_item_construct (GType object_type);
VALA_EXTERN void mail_conversation_list_item_assign (MailConversationListItem* self,
                                         MailConversationItemModel* data);
static VirtualizingListBoxRow* __mail_conversation_list_box___lambda32__virtualizing_list_box_row_factory_method (GObject* item,
                                                                                                           VirtualizingListBoxRow* old_widget,
                                                                                                           gpointer self);
static void _mail_conversation_list_box___lambda33_ (MailConversationListBox* self,
                                              GObject* row);
static Block22Data* block22_data_ref (Block22Data* _data22_);
static void block22_data_unref (void * _userdata_);
static gboolean ____lambda34_ (Block22Data* _data22_);
static gboolean _____lambda34__gsource_func (gpointer self);
static void __mail_conversation_list_box___lambda33__virtualizing_list_box_row_activated (VirtualizingListBox* _sender,
                                                                                   GObject* row,
                                                                                   gpointer self);
static void _mail_conversation_list_box___lambda35_ (MailConversationListBox* self,
                                              GObject* row);
static void __mail_conversation_list_box___lambda35__virtualizing_list_box_row_selected (VirtualizingListBox* _sender,
                                                                                  GObject* row,
                                                                                  gpointer self);
static gboolean _mail_conversation_list_box___lambda36_ (MailConversationListBox* self,
                                                  GdkEventButton* e);
VALA_EXTERN VirtualizingListBoxRow* virtualizing_list_box_get_row_at_y (VirtualizingListBox* self,
                                                            gint y);
VALA_EXTERN VirtualizingListBoxRow* virtualizing_list_box_get_selected_row_widget (VirtualizingListBox* self);
VALA_EXTERN void virtualizing_list_box_select_row (VirtualizingListBox* self,
                                       VirtualizingListBoxRow* row);
static gboolean __mail_conversation_list_box___lambda36__gtk_widget_button_release_event (GtkWidget* _sender,
                                                                                   GdkEventButton* event,
                                                                                   gpointer self);
static gboolean _mail_conversation_list_box___lambda37_ (MailConversationListBox* self,
                                                  GdkEventKey* e);
static gboolean __mail_conversation_list_box___lambda37__gtk_widget_key_release_event (GtkWidget* _sender,
                                                                                GdkEventKey* event,
                                                                                gpointer self);
static void mail_conversation_list_box_finalize (GObject * obj);
static GType mail_conversation_list_box_get_type_once (void);
static void _vala_mail_conversation_list_box_get_property (GObject * object,
                                                    guint property_id,
                                                    GValue * value,
                                                    GParamSpec * pspec);
static void _vala_mail_conversation_list_box_set_property (GObject * object,
                                                    guint property_id,
                                                    const GValue * value,
                                                    GParamSpec * pspec);
static void _vala_array_destroy (gpointer array,
                          gssize array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gssize array_length,
                       GDestroyNotify destroy_func);

static inline gpointer
mail_conversation_list_box_get_instance_private (MailConversationListBox* self)
{
	return G_STRUCT_MEMBER_P (self, MailConversationListBox_private_offset);
}

static void
mail_conversation_list_box_set_thread_flag (CamelFolderThreadNode* node,
                                            CamelMessageFlags flag)
{
	CamelMessageInfo* _tmp0_;
	CamelMessageFlags _tmp1_;
	CamelMessageFlags _tmp2_;
	if (node == NULL) {
		return;
	}
	_tmp0_ = node->message;
	g_object_get (_tmp0_, "flags", &_tmp1_, NULL);
	_tmp2_ = _tmp1_;
	if (!((((gint) _tmp2_) & flag) == flag)) {
		CamelMessageInfo* _tmp3_;
		_tmp3_ = node->message;
		camel_message_info_set_flags (_tmp3_, (guint32) flag, (guint32) (~0));
	}
	{
		CamelFolderThreadNode* child = NULL;
		CamelFolderThreadNode* _tmp4_;
		_tmp4_ = node->child;
		child = _tmp4_;
		{
			gboolean _tmp5_ = FALSE;
			_tmp5_ = TRUE;
			while (TRUE) {
				CamelFolderThreadNode* _tmp8_;
				CamelFolderThreadNode* _tmp9_;
				if (!_tmp5_) {
					CamelFolderThreadNode* _tmp6_;
					CamelFolderThreadNode* _tmp7_;
					_tmp6_ = child;
					_tmp7_ = _tmp6_->next;
					child = _tmp7_;
				}
				_tmp5_ = FALSE;
				_tmp8_ = child;
				if (!(_tmp8_ != NULL)) {
					break;
				}
				_tmp9_ = child;
				mail_conversation_list_box_set_thread_flag (_tmp9_, flag);
			}
		}
	}
}

static void
mail_conversation_list_box_load_folder_data_free (gpointer _data)
{
	MailConversationListBoxLoadFolderData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->folder_full_name_per_account);
	_g_object_unref0 (_data_->self);
	g_slice_free (MailConversationListBoxLoadFolderData, _data_);
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

void
mail_conversation_list_box_load_folder (MailConversationListBox* self,
                                        GeeMap* folder_full_name_per_account,
                                        GAsyncReadyCallback _callback_,
                                        gpointer _user_data_)
{
	MailConversationListBoxLoadFolderData* _data_;
	MailConversationListBox* _tmp0_;
	GeeMap* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (folder_full_name_per_account != NULL);
	_data_ = g_slice_new0 (MailConversationListBoxLoadFolderData);
	_data_->_async_result = g_task_new (G_OBJECT (self), NULL, _callback_, _user_data_);
	g_task_set_task_data (_data_->_async_result, _data_, mail_conversation_list_box_load_folder_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = _g_object_ref0 (folder_full_name_per_account);
	_g_object_unref0 (_data_->folder_full_name_per_account);
	_data_->folder_full_name_per_account = _tmp1_;
	mail_conversation_list_box_load_folder_co (_data_);
}

void
mail_conversation_list_box_load_folder_finish (MailConversationListBox* self,
                                               GAsyncResult* _res_)
{
	MailConversationListBoxLoadFolderData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
}

static Block20Data*
block20_data_ref (Block20Data* _data20_)
{
	g_atomic_int_inc (&_data20_->_ref_count_);
	return _data20_;
}

static void
block20_data_unref (void * _userdata_)
{
	Block20Data* _data20_;
	_data20_ = (Block20Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data20_->_ref_count_)) {
		MailConversationListBox* self;
		self = _data20_->self;
		_g_object_unref0 (_data20_->current_account);
		_g_object_unref0 (self);
		g_slice_free (Block20Data, _data20_);
	}
}

static void
mail_conversation_list_box_load_folder_ready (GObject* source_object,
                                              GAsyncResult* _res_,
                                              gpointer _user_data_)
{
	MailConversationListBoxLoadFolderData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	mail_conversation_list_box_load_folder_co (_data_);
}

static void
_________lambda24_ (Block20Data* _data20_,
                    CamelFolderChangeInfo* change_info)
{
	MailConversationListBox* self;
	MailBackendAccount* _tmp0_;
	CamelService* _tmp1_;
	CamelService* _tmp2_;
	const gchar* _tmp3_;
	const gchar* _tmp4_;
	GCancellable* _tmp5_;
	self = _data20_->self;
	g_return_if_fail (change_info != NULL);
	_tmp0_ = _data20_->current_account;
	_tmp1_ = mail_backend_account_get_service (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = camel_service_get_uid (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = self->priv->cancellable;
	mail_conversation_list_box_folder_changed (self, change_info, _tmp4_, _tmp5_);
}

static void
__________lambda24__camel_folder_changed (CamelFolder* _sender,
                                          CamelFolderChangeInfo* changes,
                                          gpointer self)
{
	_________lambda24_ (self, changes);
}

static void
_vala_CamelFolderInfo_free (CamelFolderInfo* self)
{
	g_boxed_free (camel_folder_info_get_type (), self);
}

static gboolean
mail_conversation_list_box_load_folder_co (MailConversationListBoxLoadFolderData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		case 2:
		goto _state_2;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	{
		_data_->_tmp0_ = _data_->self->priv->_folder_full_name_per_account;
		g_rec_mutex_lock (&_data_->self->priv->__lock_folder_full_name_per_account);
		{
			mail_conversation_list_box_set_folder_full_name_per_account (_data_->self, _data_->folder_full_name_per_account);
		}
		__finally0:
		{
			_data_->_tmp1_ = _data_->self->priv->_folder_full_name_per_account;
			g_rec_mutex_unlock (&_data_->self->priv->__lock_folder_full_name_per_account);
		}
		if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error0_->message, g_quark_to_string (_data_->_inner_error0_->domain), _data_->_inner_error0_->code);
			g_clear_error (&_data_->_inner_error0_);
			g_object_unref (_data_->_async_result);
			return FALSE;
		}
	}
	_data_->_tmp2_ = _data_->self->priv->cancellable;
	if (_data_->_tmp2_ != NULL) {
		_data_->_tmp3_ = _data_->self->priv->cancellable;
		g_cancellable_cancel (_data_->_tmp3_);
	}
	g_signal_emit (_data_->self, mail_conversation_list_box_signals[MAIL_CONVERSATION_LIST_BOX_CONVERSATION_FOCUSED_SIGNAL], 0, NULL);
	g_signal_emit (_data_->self, mail_conversation_list_box_signals[MAIL_CONVERSATION_LIST_BOX_CONVERSATION_SELECTED_SIGNAL], 0, NULL);
	_data_->_tmp4_ = _data_->self->priv->list_store;
	_data_->previous_items = virtualizing_list_box_model_get_n_items ((VirtualizingListBoxModel*) _data_->_tmp4_);
	{
		_data_->_tmp5_ = _data_->self->priv->conversations;
		g_rec_mutex_lock (&_data_->self->priv->__lock_conversations);
		{
			{
				_data_->_tmp6_ = _data_->self->priv->_folders;
				g_rec_mutex_lock (&_data_->self->priv->__lock_folders);
				{
					{
						_data_->_tmp7_ = _data_->self->priv->threads;
						g_rec_mutex_lock (&_data_->self->priv->__lock_threads);
						{
							_data_->_tmp8_ = _data_->self->priv->conversations;
							gee_abstract_map_clear ((GeeAbstractMap*) _data_->_tmp8_);
							_data_->_tmp9_ = _data_->self->priv->_folders;
							gee_abstract_map_clear ((GeeAbstractMap*) _data_->_tmp9_);
							_data_->_tmp10_ = _data_->self->priv->threads;
							gee_abstract_map_clear ((GeeAbstractMap*) _data_->_tmp10_);
							_data_->_tmp11_ = _data_->self->priv->list_store;
							mail_conversation_list_store_remove_all (_data_->_tmp11_);
							_data_->_tmp12_ = _data_->self->priv->list_store;
							g_list_model_items_changed ((GListModel*) _data_->_tmp12_, (guint) 0, _data_->previous_items, (guint) 0);
							_data_->_tmp13_ = g_cancellable_new ();
							_g_object_unref0 (_data_->self->priv->cancellable);
							_data_->self->priv->cancellable = _data_->_tmp13_;
							{
								_data_->_tmp14_ = _data_->self->priv->_folder_full_name_per_account;
								g_rec_mutex_lock (&_data_->self->priv->__lock_folder_full_name_per_account);
								{
									{
										_data_->_tmp15_ = _data_->self->priv->_folder_full_name_per_account;
										_data_->_tmp16_ = gee_iterable_iterator ((GeeIterable*) _data_->_tmp15_);
										_data_->_folder_full_name_entry_it = _data_->_tmp16_;
										while (TRUE) {
											_data_->_data20_ = g_slice_new0 (Block20Data);
											_data_->_data20_->_ref_count_ = 1;
											_data_->_data20_->self = g_object_ref (_data_->self);
											_data_->_tmp17_ = _data_->_folder_full_name_entry_it;
											if (!gee_iterator_next (_data_->_tmp17_)) {
												block20_data_unref (_data_->_data20_);
												_data_->_data20_ = NULL;
												break;
											}
											_data_->_tmp18_ = _data_->_folder_full_name_entry_it;
											_data_->_tmp19_ = gee_iterator_get (_data_->_tmp18_);
											_data_->folder_full_name_entry = (GeeMapEntry*) _data_->_tmp19_;
											_data_->_tmp20_ = _data_->folder_full_name_entry;
											_data_->_tmp21_ = gee_map_entry_get_key (_data_->_tmp20_);
											_data_->_tmp22_ = _data_->_tmp21_;
											_data_->_tmp23_ = _g_object_ref0 ((MailBackendAccount*) _data_->_tmp22_);
											_data_->_data20_->current_account = _data_->_tmp23_;
											_data_->_tmp24_ = _data_->folder_full_name_entry;
											_data_->_tmp25_ = gee_map_entry_get_value (_data_->_tmp24_);
											_data_->_tmp26_ = _data_->_tmp25_;
											_data_->_tmp27_ = g_strdup ((const gchar*) _data_->_tmp26_);
											_data_->current_full_name = _data_->_tmp27_;
											_data_->_tmp28_ = _data_->current_full_name;
											if (_data_->_tmp28_ == NULL) {
												_g_free0 (_data_->current_full_name);
												_g_object_unref0 (_data_->folder_full_name_entry);
												block20_data_unref (_data_->_data20_);
												_data_->_data20_ = NULL;
												continue;
											}
											{
												_data_->_tmp29_ = _data_->_data20_->current_account;
												_data_->_tmp30_ = mail_backend_account_get_service (_data_->_tmp29_);
												_data_->_tmp31_ = _data_->_tmp30_;
												_data_->_tmp32_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_data_->_tmp31_, camel_store_get_type (), CamelStore));
												_data_->camel_store = _data_->_tmp32_;
												_data_->_tmp33_ = _data_->camel_store;
												_data_->_tmp34_ = _data_->current_full_name;
												_data_->_tmp35_ = _data_->self->priv->cancellable;
												_data_->_state_ = 1;
												camel_store_get_folder (_data_->_tmp33_, _data_->_tmp34_, 0, G_PRIORITY_DEFAULT, _data_->_tmp35_, mail_conversation_list_box_load_folder_ready, _data_);
												return FALSE;
												_state_1:
												_data_->_tmp36_ = camel_store_get_folder_finish (_data_->_tmp33_, _data_->_res_, &_data_->_inner_error0_);
												_data_->folder = _data_->_tmp36_;
												if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
													_g_object_unref0 (_data_->camel_store);
													goto __catch5_g_error;
												}
												_data_->_tmp37_ = _data_->self->priv->_folders;
												_data_->_tmp38_ = _data_->_data20_->current_account;
												_data_->_tmp39_ = mail_backend_account_get_service (_data_->_tmp38_);
												_data_->_tmp40_ = _data_->_tmp39_;
												_data_->_tmp41_ = camel_service_get_uid (_data_->_tmp40_);
												_data_->_tmp42_ = _data_->_tmp41_;
												_data_->_tmp43_ = _data_->folder;
												gee_abstract_map_set ((GeeAbstractMap*) _data_->_tmp37_, _data_->_tmp42_, _data_->_tmp43_);
												_data_->_tmp45_ = _data_->camel_store;
												_data_->_tmp46_ = _data_->folder;
												_data_->_tmp47_ = camel_folder_get_full_name (_data_->_tmp46_);
												_data_->_tmp48_ = _data_->_tmp47_;
												_data_->_state_ = 2;
												camel_store_get_folder_info (_data_->_tmp45_, _data_->_tmp48_, 0, G_PRIORITY_DEFAULT, NULL, mail_conversation_list_box_load_folder_ready, _data_);
												return FALSE;
												_state_2:
												_data_->_tmp49_ = camel_store_get_folder_info_finish (_data_->_tmp45_, _data_->_res_, &_data_->_inner_error0_);
												_data_->_tmp44_ = _data_->_tmp49_;
												if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
													_g_object_unref0 (_data_->folder);
													_g_object_unref0 (_data_->camel_store);
													goto __catch5_g_error;
												}
												_data_->_tmp50_ = _data_->_data20_->current_account;
												_data_->_tmp51_ = mail_backend_account_get_service (_data_->_tmp50_);
												_data_->_tmp52_ = _data_->_tmp51_;
												_data_->info_flags = mail_utils_get_full_folder_info_flags (_data_->_tmp52_, _data_->_tmp44_);
												_data_->_tmp53_ = _data_->self->priv->_folder_info_flags;
												_data_->_tmp54_ = _data_->_data20_->current_account;
												_data_->_tmp55_ = mail_backend_account_get_service (_data_->_tmp54_);
												_data_->_tmp56_ = _data_->_tmp55_;
												_data_->_tmp57_ = camel_service_get_uid (_data_->_tmp56_);
												_data_->_tmp58_ = _data_->_tmp57_;
												gee_abstract_map_set ((GeeAbstractMap*) _data_->_tmp53_, _data_->_tmp58_, (gpointer) ((gintptr) _data_->info_flags));
												_data_->_tmp59_ = _data_->folder;
												g_signal_connect_data (_data_->_tmp59_, "changed", (GCallback) __________lambda24__camel_folder_changed, block20_data_ref (_data_->_data20_), (GClosureNotify) block20_data_unref, 0);
												_data_->_tmp60_ = _data_->_data20_->current_account;
												_data_->_tmp61_ = mail_backend_account_get_service (_data_->_tmp60_);
												_data_->_tmp62_ = _data_->_tmp61_;
												_data_->_tmp63_ = camel_service_get_uid (_data_->_tmp62_);
												_data_->_tmp64_ = _data_->_tmp63_;
												_data_->_tmp65_ = mail_conversation_list_box_get_search_result_uids (_data_->self, _data_->_tmp64_);
												_data_->search_result_uids = _data_->_tmp65_;
												_data_->_tmp66_ = _data_->search_result_uids;
												if (_data_->_tmp66_ != NULL) {
													_data_->_tmp67_ = _data_->folder;
													_data_->_tmp68_ = _data_->search_result_uids;
													_data_->_tmp69_ = camel_folder_thread_messages_new (_data_->_tmp67_, _data_->_tmp68_, FALSE);
													_data_->thread = _data_->_tmp69_;
													_data_->_tmp70_ = _data_->self->priv->threads;
													_data_->_tmp71_ = _data_->_data20_->current_account;
													_data_->_tmp72_ = mail_backend_account_get_service (_data_->_tmp71_);
													_data_->_tmp73_ = _data_->_tmp72_;
													_data_->_tmp74_ = camel_service_get_uid (_data_->_tmp73_);
													_data_->_tmp75_ = _data_->_tmp74_;
													_data_->_tmp76_ = _data_->thread;
													gee_abstract_map_set ((GeeAbstractMap*) _data_->_tmp70_, _data_->_tmp75_, _data_->_tmp76_);
													_data_->_tmp77_ = _data_->thread;
													_data_->_tmp78_ = _data_->_tmp77_->tree;
													_data_->child = _data_->_tmp78_;
													while (TRUE) {
														_data_->_tmp79_ = _data_->child;
														if (!(_data_->_tmp79_ != NULL)) {
															break;
														}
														_data_->_tmp80_ = _data_->self->priv->cancellable;
														if (g_cancellable_is_cancelled (_data_->_tmp80_)) {
															break;
														}
														_data_->_tmp81_ = _data_->self->priv->_folder_info_flags;
														_data_->_tmp82_ = _data_->_data20_->current_account;
														_data_->_tmp83_ = mail_backend_account_get_service (_data_->_tmp82_);
														_data_->_tmp84_ = _data_->_tmp83_;
														_data_->_tmp85_ = camel_service_get_uid (_data_->_tmp84_);
														_data_->_tmp86_ = _data_->_tmp85_;
														_data_->_tmp87_ = gee_abstract_map_get ((GeeAbstractMap*) _data_->_tmp81_, _data_->_tmp86_);
														_data_->_tmp88_ = _data_->child;
														_data_->_tmp89_ = _data_->thread;
														_data_->_tmp90_ = _data_->_data20_->current_account;
														_data_->_tmp91_ = mail_backend_account_get_service (_data_->_tmp90_);
														_data_->_tmp92_ = _data_->_tmp91_;
														_data_->_tmp93_ = camel_service_get_uid (_data_->_tmp92_);
														_data_->_tmp94_ = _data_->_tmp93_;
														mail_conversation_list_box_add_conversation_item (_data_->self, (CamelFolderInfoFlags) ((gintptr) _data_->_tmp87_), _data_->_tmp88_, _data_->_tmp89_, _data_->_tmp94_);
														_data_->_tmp95_ = _data_->child;
														_data_->_tmp96_ = _data_->_tmp95_->next;
														_data_->child = _data_->_tmp96_;
													}
													_camel_folder_thread_messages_unref0 (_data_->thread);
												}
												_g_ptr_array_unref0 (_data_->search_result_uids);
												__vala_CamelFolderInfo_free0 (_data_->_tmp44_);
												_g_object_unref0 (_data_->folder);
												_g_object_unref0 (_data_->camel_store);
											}
											goto __finally5;
											__catch5_g_error:
											{
												_data_->e = _data_->_inner_error0_;
												_data_->_inner_error0_ = NULL;
												_data_->_tmp97_ = _data_->e;
												if (!g_error_matches (_data_->_tmp97_, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
													_data_->_tmp98_ = _data_->e;
													_data_->_tmp99_ = _data_->_tmp98_->message;
													g_critical ("ConversationListBox.vala:212: %s", _data_->_tmp99_);
												}
												_g_error_free0 (_data_->e);
											}
											__finally5:
											if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
												_g_free0 (_data_->current_full_name);
												_g_object_unref0 (_data_->folder_full_name_entry);
												block20_data_unref (_data_->_data20_);
												_data_->_data20_ = NULL;
												_g_object_unref0 (_data_->_folder_full_name_entry_it);
												{
													_data_->_tmp100_ = _data_->self->priv->threads;
													g_rec_mutex_unlock (&_data_->self->priv->__lock_threads);
												}
												{
													_data_->_tmp101_ = _data_->self->priv->_folders;
													g_rec_mutex_unlock (&_data_->self->priv->__lock_folders);
												}
												{
													_data_->_tmp102_ = _data_->self->priv->conversations;
													g_rec_mutex_unlock (&_data_->self->priv->__lock_conversations);
												}
												g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error0_->message, g_quark_to_string (_data_->_inner_error0_->domain), _data_->_inner_error0_->code);
												g_clear_error (&_data_->_inner_error0_);
												g_object_unref (_data_->_async_result);
												return FALSE;
											}
											_g_free0 (_data_->current_full_name);
											_g_object_unref0 (_data_->folder_full_name_entry);
											block20_data_unref (_data_->_data20_);
											_data_->_data20_ = NULL;
										}
										_g_object_unref0 (_data_->_folder_full_name_entry_it);
									}
								}
								__finally4:
								{
									_data_->_tmp103_ = _data_->self->priv->_folder_full_name_per_account;
									g_rec_mutex_unlock (&_data_->self->priv->__lock_folder_full_name_per_account);
								}
								if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
									{
										_data_->_tmp104_ = _data_->self->priv->_folders;
										g_rec_mutex_unlock (&_data_->self->priv->__lock_folders);
									}
									{
										_data_->_tmp105_ = _data_->self->priv->conversations;
										g_rec_mutex_unlock (&_data_->self->priv->__lock_conversations);
									}
									g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error0_->message, g_quark_to_string (_data_->_inner_error0_->domain), _data_->_inner_error0_->code);
									g_clear_error (&_data_->_inner_error0_);
									g_object_unref (_data_->_async_result);
									return FALSE;
								}
							}
						}
						__finally3:
						{
							_data_->_tmp106_ = _data_->self->priv->threads;
							g_rec_mutex_unlock (&_data_->self->priv->__lock_threads);
						}
						if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
							{
								_data_->_tmp107_ = _data_->self->priv->conversations;
								g_rec_mutex_unlock (&_data_->self->priv->__lock_conversations);
							}
							g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error0_->message, g_quark_to_string (_data_->_inner_error0_->domain), _data_->_inner_error0_->code);
							g_clear_error (&_data_->_inner_error0_);
							g_object_unref (_data_->_async_result);
							return FALSE;
						}
					}
				}
				__finally2:
				{
					_data_->_tmp108_ = _data_->self->priv->_folders;
					g_rec_mutex_unlock (&_data_->self->priv->__lock_folders);
				}
				if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
					g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error0_->message, g_quark_to_string (_data_->_inner_error0_->domain), _data_->_inner_error0_->code);
					g_clear_error (&_data_->_inner_error0_);
					g_object_unref (_data_->_async_result);
					return FALSE;
				}
			}
		}
		__finally1:
		{
			_data_->_tmp109_ = _data_->self->priv->conversations;
			g_rec_mutex_unlock (&_data_->self->priv->__lock_conversations);
		}
		if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error0_->message, g_quark_to_string (_data_->_inner_error0_->domain), _data_->_inner_error0_->code);
			g_clear_error (&_data_->_inner_error0_);
			g_object_unref (_data_->_async_result);
			return FALSE;
		}
	}
	_data_->_tmp110_ = _data_->self->priv->list_store;
	_data_->_tmp111_ = _data_->self->priv->list_store;
	g_list_model_items_changed ((GListModel*) _data_->_tmp110_, (guint) 0, (guint) 0, virtualizing_list_box_model_get_n_items ((VirtualizingListBoxModel*) _data_->_tmp111_));
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (!g_task_get_completed (_data_->_async_result)) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}

static void
mail_conversation_list_box_refresh_folder_data_free (gpointer _data)
{
	MailConversationListBoxRefreshFolderData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->cancellable);
	_g_object_unref0 (_data_->self);
	g_slice_free (MailConversationListBoxRefreshFolderData, _data_);
}

void
mail_conversation_list_box_refresh_folder (MailConversationListBox* self,
                                           GCancellable* cancellable,
                                           GAsyncReadyCallback _callback_,
                                           gpointer _user_data_)
{
	MailConversationListBoxRefreshFolderData* _data_;
	MailConversationListBox* _tmp0_;
	GCancellable* _tmp1_;
	g_return_if_fail (self != NULL);
	_data_ = g_slice_new0 (MailConversationListBoxRefreshFolderData);
	_data_->_async_result = g_task_new (G_OBJECT (self), cancellable, _callback_, _user_data_);
	g_task_set_task_data (_data_->_async_result, _data_, mail_conversation_list_box_refresh_folder_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = _g_object_ref0 (cancellable);
	_g_object_unref0 (_data_->cancellable);
	_data_->cancellable = _tmp1_;
	mail_conversation_list_box_refresh_folder_co (_data_);
}

void
mail_conversation_list_box_refresh_folder_finish (MailConversationListBox* self,
                                                  GAsyncResult* _res_)
{
	MailConversationListBoxRefreshFolderData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
	if (NULL == _data_) {
		return;
	}
}

static void
mail_conversation_list_box_refresh_folder_ready (GObject* source_object,
                                                 GAsyncResult* _res_,
                                                 gpointer _user_data_)
{
	MailConversationListBoxRefreshFolderData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	mail_conversation_list_box_refresh_folder_co (_data_);
}

static gboolean
mail_conversation_list_box_refresh_folder_co (MailConversationListBoxRefreshFolderData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	{
		_data_->_tmp0_ = _data_->self->priv->_folders;
		g_rec_mutex_lock (&_data_->self->priv->__lock_folders);
		{
			{
				_data_->_tmp1_ = _data_->self->priv->_folders;
				_data_->_tmp2_ = gee_abstract_map_get_values ((GeeAbstractMap*) _data_->_tmp1_);
				_data_->_tmp3_ = _data_->_tmp2_;
				_data_->_tmp4_ = _data_->_tmp3_;
				_data_->_tmp5_ = gee_iterable_iterator ((GeeIterable*) _data_->_tmp4_);
				_data_->_tmp6_ = _data_->_tmp5_;
				_g_object_unref0 (_data_->_tmp4_);
				_data_->_folder_it = _data_->_tmp6_;
				while (TRUE) {
					_data_->_tmp7_ = _data_->_folder_it;
					if (!gee_iterator_next (_data_->_tmp7_)) {
						break;
					}
					_data_->_tmp8_ = _data_->_folder_it;
					_data_->_tmp9_ = gee_iterator_get (_data_->_tmp8_);
					_data_->folder = (CamelFolder*) _data_->_tmp9_;
					{
						_data_->_tmp10_ = _data_->folder;
						_data_->_state_ = 1;
						camel_folder_refresh_info (_data_->_tmp10_, G_PRIORITY_DEFAULT, _data_->cancellable, mail_conversation_list_box_refresh_folder_ready, _data_);
						return FALSE;
						_state_1:
						camel_folder_refresh_info_finish (_data_->_tmp10_, _data_->_res_, &_data_->_inner_error0_);
						if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
							goto __catch1_g_error;
						}
					}
					goto __finally1;
					__catch1_g_error:
					{
						_data_->e = _data_->_inner_error0_;
						_data_->_inner_error0_ = NULL;
						_data_->_tmp11_ = _data_->folder;
						_data_->_tmp12_ = camel_folder_get_display_name (_data_->_tmp11_);
						_data_->_tmp13_ = _data_->_tmp12_;
						_data_->_tmp14_ = _data_->folder;
						_data_->_tmp15_ = camel_folder_get_parent_store (_data_->_tmp14_);
						_data_->_tmp16_ = _data_->_tmp15_;
						_data_->_tmp17_ = camel_service_get_display_name ((CamelService*) _data_->_tmp16_);
						_data_->_tmp18_ = _data_->_tmp17_;
						_data_->_tmp19_ = _data_->e;
						_data_->_tmp20_ = _data_->_tmp19_->message;
						g_warning ("ConversationListBox.vala:230: Error fetching messages for '%s' from '%" \
"s': %s", _data_->_tmp13_, _data_->_tmp18_, _data_->_tmp20_);
						_g_error_free0 (_data_->e);
					}
					__finally1:
					if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
						_g_object_unref0 (_data_->folder);
						_g_object_unref0 (_data_->_folder_it);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error0_->message, g_quark_to_string (_data_->_inner_error0_->domain), _data_->_inner_error0_->code);
						g_clear_error (&_data_->_inner_error0_);
						g_object_unref (_data_->_async_result);
						return FALSE;
					}
					_g_object_unref0 (_data_->folder);
				}
				_g_object_unref0 (_data_->_folder_it);
			}
		}
		__finally0:
		{
			_data_->_tmp21_ = _data_->self->priv->_folders;
			g_rec_mutex_unlock (&_data_->self->priv->__lock_folders);
		}
		if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error0_->message, g_quark_to_string (_data_->_inner_error0_->domain), _data_->_inner_error0_->code);
			g_clear_error (&_data_->_inner_error0_);
			g_object_unref (_data_->_async_result);
			return FALSE;
		}
	}
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (!g_task_get_completed (_data_->_async_result)) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}

static Block21Data*
block21_data_ref (Block21Data* _data21_)
{
	g_atomic_int_inc (&_data21_->_ref_count_);
	return _data21_;
}

static void
block21_data_unref (void * _userdata_)
{
	Block21Data* _data21_;
	_data21_ = (Block21Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data21_->_ref_count_)) {
		MailConversationListBox* self;
		self = _data21_->self;
		_g_object_unref0 (self);
		g_slice_free (Block21Data, _data21_);
	}
}

static void
____lambda25_ (Block21Data* _data21_,
               const gchar* uid)
{
	MailConversationListBox* self;
	MailConversationItemModel* item = NULL;
	GeeHashMap* _tmp0_;
	gpointer _tmp1_;
	MailConversationItemModel* _tmp2_;
	self = _data21_->self;
	g_return_if_fail (uid != NULL);
	_tmp0_ = self->priv->conversations;
	_tmp1_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp0_, uid);
	item = (MailConversationItemModel*) _tmp1_;
	_tmp2_ = item;
	if (_tmp2_ != NULL) {
		GeeHashMap* _tmp3_;
		MailConversationListStore* _tmp4_;
		MailConversationItemModel* _tmp5_;
		gint _tmp6_;
		_tmp3_ = self->priv->conversations;
		gee_abstract_map_unset ((GeeAbstractMap*) _tmp3_, uid, NULL);
		_tmp4_ = self->priv->list_store;
		_tmp5_ = item;
		mail_conversation_list_store_remove (_tmp4_, _tmp5_);
		_tmp6_ = _data21_->removed;
		_data21_->removed = _tmp6_ + 1;
	}
	_g_object_unref0 (item);
}

static void
_____lambda25__gfunc (gconstpointer data,
                      gpointer self)
{
	____lambda25_ (self, (const gchar*) data);
}

static void
mail_conversation_list_box_folder_changed (MailConversationListBox* self,
                                           CamelFolderChangeInfo* change_info,
                                           const gchar* service_uid,
                                           GCancellable* cancellable)
{
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (change_info != NULL);
	g_return_if_fail (service_uid != NULL);
	g_return_if_fail (cancellable != NULL);
	if (g_cancellable_is_cancelled (cancellable)) {
		return;
	}
	{
		GeeHashMap* _tmp0_;
		_tmp0_ = self->priv->conversations;
		g_rec_mutex_lock (&self->priv->__lock_conversations);
		{
			{
				GeeHashMap* _tmp1_;
				_tmp1_ = self->priv->threads;
				g_rec_mutex_lock (&self->priv->__lock_threads);
				{
					Block21Data* _data21_;
					GPtrArray* search_result_uids = NULL;
					GPtrArray* _tmp2_;
					GPtrArray* _tmp3_;
					GeeHashMap* _tmp6_;
					gpointer _tmp7_;
					CamelFolderThread* _tmp8_;
					GPtrArray* _tmp9_;
					GPtrArray* _tmp10_;
					CamelFolderThreadNode* child = NULL;
					GeeHashMap* _tmp11_;
					gpointer _tmp12_;
					CamelFolderThread* _tmp13_;
					CamelFolderThreadNode* _tmp14_;
					CamelFolderThreadNode* _tmp15_;
					MailConversationListStore* _tmp50_;
					MailConversationListStore* _tmp51_;
					_data21_ = g_slice_new0 (Block21Data);
					_data21_->_ref_count_ = 1;
					_data21_->self = g_object_ref (self);
					_tmp2_ = mail_conversation_list_box_get_search_result_uids (self, service_uid);
					search_result_uids = _tmp2_;
					_tmp3_ = search_result_uids;
					if (_tmp3_ == NULL) {
						_g_ptr_array_unref0 (search_result_uids);
						block21_data_unref (_data21_);
						_data21_ = NULL;
						{
							GeeHashMap* _tmp4_;
							_tmp4_ = self->priv->threads;
							g_rec_mutex_unlock (&self->priv->__lock_threads);
						}
						{
							GeeHashMap* _tmp5_;
							_tmp5_ = self->priv->conversations;
							g_rec_mutex_unlock (&self->priv->__lock_conversations);
						}
						return;
					}
					_tmp6_ = self->priv->threads;
					_tmp7_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp6_, service_uid);
					_tmp8_ = (CamelFolderThread*) _tmp7_;
					_tmp9_ = search_result_uids;
					camel_folder_thread_messages_apply (_tmp8_, _tmp9_);
					_camel_folder_thread_messages_unref0 (_tmp8_);
					_data21_->removed = 0;
					_tmp10_ = camel_folder_change_info_get_removed_uids (change_info);
					g_ptr_array_foreach (_tmp10_, _____lambda25__gfunc, _data21_);
					_tmp11_ = self->priv->threads;
					_tmp12_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp11_, service_uid);
					_tmp13_ = (CamelFolderThread*) _tmp12_;
					_tmp14_ = _tmp13_->tree;
					_tmp15_ = _tmp14_;
					_camel_folder_thread_messages_unref0 (_tmp13_);
					child = _tmp15_;
					while (TRUE) {
						CamelFolderThreadNode* _tmp16_;
						MailConversationItemModel* item = NULL;
						GeeHashMap* _tmp19_;
						CamelFolderThreadNode* _tmp20_;
						CamelMessageInfo* _tmp21_;
						const gchar* _tmp22_;
						const gchar* _tmp23_;
						gpointer _tmp24_;
						MailConversationItemModel* _tmp25_;
						CamelFolderThreadNode* _tmp48_;
						CamelFolderThreadNode* _tmp49_;
						_tmp16_ = child;
						if (!(_tmp16_ != NULL)) {
							break;
						}
						if (g_cancellable_is_cancelled (cancellable)) {
							_g_ptr_array_unref0 (search_result_uids);
							block21_data_unref (_data21_);
							_data21_ = NULL;
							{
								GeeHashMap* _tmp17_;
								_tmp17_ = self->priv->threads;
								g_rec_mutex_unlock (&self->priv->__lock_threads);
							}
							{
								GeeHashMap* _tmp18_;
								_tmp18_ = self->priv->conversations;
								g_rec_mutex_unlock (&self->priv->__lock_conversations);
							}
							return;
						}
						_tmp19_ = self->priv->conversations;
						_tmp20_ = child;
						_tmp21_ = _tmp20_->message;
						_tmp22_ = camel_message_info_get_uid (_tmp21_);
						_tmp23_ = _tmp22_;
						_tmp24_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp19_, _tmp23_);
						item = (MailConversationItemModel*) _tmp24_;
						_tmp25_ = item;
						if (_tmp25_ == NULL) {
							GeeHashMap* _tmp26_;
							gpointer _tmp27_;
							CamelFolderThreadNode* _tmp28_;
							GeeHashMap* _tmp29_;
							gpointer _tmp30_;
							CamelFolderThread* _tmp31_;
							_tmp26_ = self->priv->_folder_info_flags;
							_tmp27_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp26_, service_uid);
							_tmp28_ = child;
							_tmp29_ = self->priv->threads;
							_tmp30_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp29_, service_uid);
							_tmp31_ = (CamelFolderThread*) _tmp30_;
							mail_conversation_list_box_add_conversation_item (self, (CamelFolderInfoFlags) ((gintptr) _tmp27_), _tmp28_, _tmp31_, service_uid);
							_camel_folder_thread_messages_unref0 (_tmp31_);
						} else {
							MailConversationItemModel* _tmp32_;
							CamelFolderThreadNode* _tmp33_;
							_tmp32_ = item;
							_tmp33_ = child;
							if (mail_conversation_item_model_is_older_than (_tmp32_, _tmp33_)) {
								GeeHashMap* _tmp34_;
								CamelFolderThreadNode* _tmp35_;
								CamelMessageInfo* _tmp36_;
								const gchar* _tmp37_;
								const gchar* _tmp38_;
								MailConversationListStore* _tmp39_;
								MailConversationItemModel* _tmp40_;
								gint _tmp41_;
								GeeHashMap* _tmp42_;
								gpointer _tmp43_;
								CamelFolderThreadNode* _tmp44_;
								GeeHashMap* _tmp45_;
								gpointer _tmp46_;
								CamelFolderThread* _tmp47_;
								_tmp34_ = self->priv->conversations;
								_tmp35_ = child;
								_tmp36_ = _tmp35_->message;
								_tmp37_ = camel_message_info_get_uid (_tmp36_);
								_tmp38_ = _tmp37_;
								gee_abstract_map_unset ((GeeAbstractMap*) _tmp34_, _tmp38_, NULL);
								_tmp39_ = self->priv->list_store;
								_tmp40_ = item;
								mail_conversation_list_store_remove (_tmp39_, _tmp40_);
								_tmp41_ = _data21_->removed;
								_data21_->removed = _tmp41_ + 1;
								_tmp42_ = self->priv->_folder_info_flags;
								_tmp43_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp42_, service_uid);
								_tmp44_ = child;
								_tmp45_ = self->priv->threads;
								_tmp46_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp45_, service_uid);
								_tmp47_ = (CamelFolderThread*) _tmp46_;
								mail_conversation_list_box_add_conversation_item (self, (CamelFolderInfoFlags) ((gintptr) _tmp43_), _tmp44_, _tmp47_, service_uid);
								_camel_folder_thread_messages_unref0 (_tmp47_);
							}
						}
						_tmp48_ = child;
						_tmp49_ = _tmp48_->next;
						child = _tmp49_;
						_g_object_unref0 (item);
					}
					_tmp50_ = self->priv->list_store;
					_tmp51_ = self->priv->list_store;
					g_list_model_items_changed ((GListModel*) _tmp50_, (guint) 0, (guint) _data21_->removed, virtualizing_list_box_model_get_n_items ((VirtualizingListBoxModel*) _tmp51_));
					_g_ptr_array_unref0 (search_result_uids);
					block21_data_unref (_data21_);
					_data21_ = NULL;
				}
				__finally1:
				{
					GeeHashMap* _tmp52_;
					_tmp52_ = self->priv->threads;
					g_rec_mutex_unlock (&self->priv->__lock_threads);
				}
				if (G_UNLIKELY (_inner_error0_ != NULL)) {
					g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
					g_clear_error (&_inner_error0_);
					return;
				}
			}
		}
		__finally0:
		{
			GeeHashMap* _tmp53_;
			_tmp53_ = self->priv->conversations;
			g_rec_mutex_unlock (&self->priv->__lock_conversations);
		}
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return;
		}
	}
}

static gchar*
string_strip (const gchar* self)
{
	gchar* _result_ = NULL;
	gchar* _tmp0_;
	gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self);
	_result_ = _tmp0_;
	g_strstrip (_result_);
	result = _result_;
	return result;
}

static gpointer
_g_ptr_array_ref0 (gpointer self)
{
	return self ? g_ptr_array_ref (self) : NULL;
}

static void
_vala_array_add3 (gchar** * array,
                  gint* length,
                  gint* size,
                  gchar* value)
{
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}

static void
_vala_array_add4 (gchar** * array,
                  gint* length,
                  gint* size,
                  gchar* value)
{
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}

static void
_vala_array_add5 (gchar** * array,
                  gint* length,
                  gint* size,
                  gchar* value)
{
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}

static gchar*
_vala_g_strjoinv (const gchar* separator,
                  gchar** str_array,
                  gint str_array_length1)
{
	gboolean _tmp0_ = FALSE;
	gchar* result;
	if (separator == NULL) {
		separator = "";
	}
	if (str_array != NULL) {
		gboolean _tmp1_ = FALSE;
		if (str_array_length1 > 0) {
			_tmp1_ = TRUE;
		} else {
			gboolean _tmp2_ = FALSE;
			if (str_array_length1 == -1) {
				const gchar* _tmp3_;
				_tmp3_ = str_array[0];
				_tmp2_ = _tmp3_ != NULL;
			} else {
				_tmp2_ = FALSE;
			}
			_tmp1_ = _tmp2_;
		}
		_tmp0_ = _tmp1_;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		gint i = 0;
		gsize len = 0UL;
		gint _tmp16_;
		gint _tmp17_;
		const gchar* res = NULL;
		void* _tmp18_;
		const gchar* _tmp19_ = NULL;
		const gchar* _tmp20_;
		void* ptr = NULL;
		const gchar* _tmp22_;
		void* _tmp23_;
		const gchar* _tmp33_;
		len = (gsize) 1;
		{
			gboolean _tmp4_ = FALSE;
			i = 0;
			_tmp4_ = TRUE;
			while (TRUE) {
				gboolean _tmp6_ = FALSE;
				gboolean _tmp7_ = FALSE;
				gint _tmp10_ = 0;
				const gchar* _tmp11_;
				if (!_tmp4_) {
					gint _tmp5_;
					_tmp5_ = i;
					i = _tmp5_ + 1;
				}
				_tmp4_ = FALSE;
				if (str_array_length1 != -1) {
					_tmp7_ = i < str_array_length1;
				} else {
					_tmp7_ = FALSE;
				}
				if (_tmp7_) {
					_tmp6_ = TRUE;
				} else {
					gboolean _tmp8_ = FALSE;
					if (str_array_length1 == -1) {
						const gchar* _tmp9_;
						_tmp9_ = str_array[i];
						_tmp8_ = _tmp9_ != NULL;
					} else {
						_tmp8_ = FALSE;
					}
					_tmp6_ = _tmp8_;
				}
				if (!_tmp6_) {
					break;
				}
				_tmp11_ = str_array[i];
				if (_tmp11_ != NULL) {
					const gchar* _tmp12_;
					gint _tmp13_;
					gint _tmp14_;
					_tmp12_ = str_array[i];
					_tmp13_ = strlen ((const gchar*) _tmp12_);
					_tmp14_ = _tmp13_;
					_tmp10_ = _tmp14_;
				} else {
					_tmp10_ = 0;
				}
				len += (gsize) _tmp10_;
			}
		}
		if (i == 0) {
			gchar* _tmp15_;
			_tmp15_ = g_strdup ("");
			result = _tmp15_;
			return result;
		}
		str_array_length1 = i;
		_tmp16_ = strlen ((const gchar*) separator);
		_tmp17_ = _tmp16_;
		len += (gsize) (_tmp17_ * (i - 1));
		_tmp18_ = g_malloc (len);
		res = _tmp18_;
		_tmp20_ = str_array[0];
		if (_tmp20_ != NULL) {
			const gchar* _tmp21_;
			_tmp21_ = str_array[0];
			_tmp19_ = (const gchar*) _tmp21_;
		} else {
			_tmp19_ = "";
		}
		_tmp22_ = res;
		_tmp23_ = g_stpcpy ((void*) _tmp22_, _tmp19_);
		ptr = _tmp23_;
		{
			gboolean _tmp24_ = FALSE;
			i = 1;
			_tmp24_ = TRUE;
			while (TRUE) {
				void* _tmp26_;
				void* _tmp27_;
				const gchar* _tmp28_ = NULL;
				const gchar* _tmp29_;
				void* _tmp31_;
				void* _tmp32_;
				if (!_tmp24_) {
					gint _tmp25_;
					_tmp25_ = i;
					i = _tmp25_ + 1;
				}
				_tmp24_ = FALSE;
				if (!(i < str_array_length1)) {
					break;
				}
				_tmp26_ = ptr;
				_tmp27_ = g_stpcpy (_tmp26_, (const gchar*) separator);
				ptr = _tmp27_;
				_tmp29_ = str_array[i];
				if (_tmp29_ != NULL) {
					const gchar* _tmp30_;
					_tmp30_ = str_array[i];
					_tmp28_ = (const gchar*) _tmp30_;
				} else {
					_tmp28_ = "";
				}
				_tmp31_ = ptr;
				_tmp32_ = g_stpcpy (_tmp31_, _tmp28_);
				ptr = _tmp32_;
			}
		}
		_tmp33_ = res;
		res = NULL;
		result = (gchar*) _tmp33_;
		return result;
	} else {
		gchar* _tmp34_;
		_tmp34_ = g_strdup ("");
		result = _tmp34_;
		return result;
	}
}

static GPtrArray*
mail_conversation_list_box_get_search_result_uids (MailConversationListBox* self,
                                                   const gchar* service_uid)
{
	GError* _inner_error0_ = NULL;
	GPtrArray* result;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (service_uid != NULL, NULL);
	{
		GeeHashMap* _tmp0_;
		_tmp0_ = self->priv->_folders;
		g_rec_mutex_lock (&self->priv->__lock_folders);
		{
			GeeHashMap* _tmp1_;
			gpointer _tmp2_;
			CamelFolder* _tmp3_;
			gboolean _tmp4_;
			gboolean _tmp6_ = FALSE;
			const gchar* _tmp7_;
			gboolean has_current_search_query = FALSE;
			gboolean _tmp11_ = FALSE;
			gboolean _tmp12_ = FALSE;
			gchar** current_search_expressions = NULL;
			gchar** _tmp20_;
			gint current_search_expressions_length1;
			gint _current_search_expressions_size_;
			gchar* search_query = NULL;
			gchar** _tmp33_;
			gint _tmp33__length1;
			gchar* _tmp34_;
			gchar* _tmp35_;
			gchar* _tmp36_;
			gchar* _tmp37_;
			gchar* _tmp38_;
			gchar* _tmp39_;
			_tmp1_ = self->priv->_folders;
			_tmp2_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp1_, service_uid);
			_tmp3_ = (CamelFolder*) _tmp2_;
			_tmp4_ = _tmp3_ == NULL;
			_g_object_unref0 (_tmp3_);
			if (_tmp4_) {
				result = NULL;
				{
					GeeHashMap* _tmp5_;
					_tmp5_ = self->priv->_folders;
					g_rec_mutex_unlock (&self->priv->__lock_folders);
				}
				return result;
			}
			_tmp7_ = self->priv->current_search_query;
			if (_tmp7_ != NULL) {
				const gchar* _tmp8_;
				gchar* _tmp9_;
				gchar* _tmp10_;
				_tmp8_ = self->priv->current_search_query;
				_tmp9_ = string_strip (_tmp8_);
				_tmp10_ = _tmp9_;
				_tmp6_ = g_strcmp0 (_tmp10_, "") != 0;
				_g_free0 (_tmp10_);
			} else {
				_tmp6_ = FALSE;
			}
			has_current_search_query = _tmp6_;
			if (!has_current_search_query) {
				_tmp12_ = !self->priv->current_search_hide_read;
			} else {
				_tmp12_ = FALSE;
			}
			if (_tmp12_) {
				_tmp11_ = !self->priv->current_search_hide_unstarred;
			} else {
				_tmp11_ = FALSE;
			}
			if (_tmp11_) {
				GeeHashMap* _tmp13_;
				gpointer _tmp14_;
				CamelFolder* _tmp15_;
				GPtrArray* _tmp16_;
				GPtrArray* _tmp17_;
				GPtrArray* _tmp18_;
				_tmp13_ = self->priv->_folders;
				_tmp14_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp13_, service_uid);
				_tmp15_ = (CamelFolder*) _tmp14_;
				_tmp16_ = camel_folder_get_uids (_tmp15_);
				_tmp17_ = _g_ptr_array_ref0 (_tmp16_);
				_tmp18_ = _tmp17_;
				_g_object_unref0 (_tmp15_);
				result = _tmp18_;
				{
					GeeHashMap* _tmp19_;
					_tmp19_ = self->priv->_folders;
					g_rec_mutex_unlock (&self->priv->__lock_folders);
				}
				return result;
			}
			_tmp20_ = g_new0 (gchar*, 0 + 1);
			current_search_expressions = _tmp20_;
			current_search_expressions_length1 = 0;
			_current_search_expressions_size_ = current_search_expressions_length1;
			if (self->priv->current_search_hide_read) {
				gchar* _tmp21_;
				_tmp21_ = g_strdup ("(not (system-flag \"Seen\"))");
				_vala_array_add3 (&current_search_expressions, &current_search_expressions_length1, &_current_search_expressions_size_, _tmp21_);
			}
			if (self->priv->current_search_hide_unstarred) {
				gchar* _tmp22_;
				_tmp22_ = g_strdup ("(system-flag \"Flagged\")");
				_vala_array_add4 (&current_search_expressions, &current_search_expressions_length1, &_current_search_expressions_size_, _tmp22_);
			}
			if (has_current_search_query) {
				GString* sb = NULL;
				GString* _tmp23_;
				GString* _tmp24_;
				const gchar* _tmp25_;
				gchar* encoded_query = NULL;
				GString* _tmp26_;
				const gchar* _tmp27_;
				gchar* _tmp28_;
				const gchar* _tmp29_;
				const gchar* _tmp30_;
				const gchar* _tmp31_;
				gchar* _tmp32_;
				_tmp23_ = g_string_new ("");
				sb = _tmp23_;
				_tmp24_ = sb;
				_tmp25_ = self->priv->current_search_query;
				camel_sexp_encode_string (_tmp24_, _tmp25_);
				_tmp26_ = sb;
				_tmp27_ = _tmp26_->str;
				_tmp28_ = g_strdup (_tmp27_);
				encoded_query = _tmp28_;
				_tmp29_ = encoded_query;
				_tmp30_ = encoded_query;
				_tmp31_ = encoded_query;
				_tmp32_ = g_strdup_printf ("(or (header-contains \"From\" %s)(header-contains \"Subject\" %s)(body" \
"-contains %s))", _tmp29_, _tmp30_, _tmp31_);
				_vala_array_add5 (&current_search_expressions, &current_search_expressions_length1, &_current_search_expressions_size_, _tmp32_);
				_g_free0 (encoded_query);
				_g_string_free0 (sb);
			}
			_tmp33_ = current_search_expressions;
			_tmp33__length1 = current_search_expressions_length1;
			_tmp34_ = _vala_g_strjoinv ("", _tmp33_, (gint) _tmp33__length1);
			_tmp35_ = _tmp34_;
			_tmp36_ = g_strconcat ("(match-all (and ", _tmp35_, NULL);
			_tmp37_ = _tmp36_;
			_tmp38_ = g_strconcat (_tmp37_, "))", NULL);
			_tmp39_ = _tmp38_;
			_g_free0 (_tmp37_);
			_g_free0 (_tmp35_);
			search_query = _tmp39_;
			{
				GPtrArray* _tmp40_ = NULL;
				GeeHashMap* _tmp41_;
				gpointer _tmp42_;
				CamelFolder* _tmp43_;
				const gchar* _tmp44_;
				GCancellable* _tmp45_;
				GPtrArray* _tmp46_;
				GPtrArray* _tmp47_;
				GPtrArray* _tmp48_;
				_tmp41_ = self->priv->_folders;
				_tmp42_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp41_, service_uid);
				_tmp43_ = (CamelFolder*) _tmp42_;
				_tmp44_ = search_query;
				_tmp45_ = self->priv->cancellable;
				_tmp46_ = camel_folder_search_by_expression (_tmp43_, _tmp44_, _tmp45_, &_inner_error0_);
				_tmp47_ = _tmp46_;
				_g_object_unref0 (_tmp43_);
				_tmp40_ = _tmp47_;
				if (G_UNLIKELY (_inner_error0_ != NULL)) {
					goto __catch1_g_error;
				}
				_tmp48_ = _tmp40_;
				_tmp40_ = NULL;
				result = _tmp48_;
				_g_ptr_array_unref0 (_tmp40_);
				_g_free0 (search_query);
				current_search_expressions = (_vala_array_free (current_search_expressions, current_search_expressions_length1, (GDestroyNotify) g_free), NULL);
				{
					GeeHashMap* _tmp49_;
					_tmp49_ = self->priv->_folders;
					g_rec_mutex_unlock (&self->priv->__lock_folders);
				}
				return result;
			}
			goto __finally1;
			__catch1_g_error:
			{
				GError* e = NULL;
				GError* _tmp50_;
				GeeHashMap* _tmp53_;
				gpointer _tmp54_;
				CamelFolder* _tmp55_;
				GPtrArray* _tmp56_;
				GPtrArray* _tmp57_;
				GPtrArray* _tmp58_;
				e = _inner_error0_;
				_inner_error0_ = NULL;
				_tmp50_ = e;
				if (!g_error_matches (_tmp50_, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
					GError* _tmp51_;
					const gchar* _tmp52_;
					_tmp51_ = e;
					_tmp52_ = _tmp51_->message;
					g_warning ("ConversationListBox.vala:325: Error while searching: %s", _tmp52_);
				}
				_tmp53_ = self->priv->_folders;
				_tmp54_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp53_, service_uid);
				_tmp55_ = (CamelFolder*) _tmp54_;
				_tmp56_ = camel_folder_get_uids (_tmp55_);
				_tmp57_ = _g_ptr_array_ref0 (_tmp56_);
				_tmp58_ = _tmp57_;
				_g_object_unref0 (_tmp55_);
				result = _tmp58_;
				_g_error_free0 (e);
				_g_free0 (search_query);
				current_search_expressions = (_vala_array_free (current_search_expressions, current_search_expressions_length1, (GDestroyNotify) g_free), NULL);
				{
					GeeHashMap* _tmp59_;
					_tmp59_ = self->priv->_folders;
					g_rec_mutex_unlock (&self->priv->__lock_folders);
				}
				return result;
			}
			__finally1:
			_g_free0 (search_query);
			current_search_expressions = (_vala_array_free (current_search_expressions, current_search_expressions_length1, (GDestroyNotify) g_free), NULL);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return NULL;
		}
		__finally0:
		{
			GeeHashMap* _tmp60_;
			_tmp60_ = self->priv->_folders;
			g_rec_mutex_unlock (&self->priv->__lock_folders);
		}
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return NULL;
	}
}

static void
mail_conversation_list_box_search_data_free (gpointer _data)
{
	MailConversationListBoxSearchData* _data_;
	_data_ = _data;
	_g_free0 (_data_->query);
	_g_object_unref0 (_data_->self);
	g_slice_free (MailConversationListBoxSearchData, _data_);
}

void
mail_conversation_list_box_search (MailConversationListBox* self,
                                   const gchar* query,
                                   gboolean hide_read,
                                   gboolean hide_unstarred,
                                   GAsyncReadyCallback _callback_,
                                   gpointer _user_data_)
{
	MailConversationListBoxSearchData* _data_;
	MailConversationListBox* _tmp0_;
	gchar* _tmp1_;
	g_return_if_fail (self != NULL);
	_data_ = g_slice_new0 (MailConversationListBoxSearchData);
	_data_->_async_result = g_task_new (G_OBJECT (self), NULL, _callback_, _user_data_);
	g_task_set_task_data (_data_->_async_result, _data_, mail_conversation_list_box_search_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = g_strdup (query);
	_g_free0 (_data_->query);
	_data_->query = _tmp1_;
	_data_->hide_read = hide_read;
	_data_->hide_unstarred = hide_unstarred;
	mail_conversation_list_box_search_co (_data_);
}

void
mail_conversation_list_box_search_finish (MailConversationListBox* self,
                                          GAsyncResult* _res_)
{
	MailConversationListBoxSearchData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
}

static void
mail_conversation_list_box_search_ready (GObject* source_object,
                                         GAsyncResult* _res_,
                                         gpointer _user_data_)
{
	MailConversationListBoxSearchData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	mail_conversation_list_box_search_co (_data_);
}

static gboolean
mail_conversation_list_box_search_co (MailConversationListBoxSearchData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = g_strdup (_data_->query);
	_g_free0 (_data_->self->priv->current_search_query);
	_data_->self->priv->current_search_query = _data_->_tmp0_;
	_data_->self->priv->current_search_hide_read = _data_->hide_read;
	_data_->self->priv->current_search_hide_unstarred = _data_->hide_unstarred;
	_data_->_tmp1_ = _data_->self->priv->_folder_full_name_per_account;
	_data_->_state_ = 1;
	mail_conversation_list_box_load_folder (_data_->self, _data_->_tmp1_, mail_conversation_list_box_search_ready, _data_);
	return FALSE;
	_state_1:
	mail_conversation_list_box_load_folder_finish (_data_->self, _data_->_res_);
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (!g_task_get_completed (_data_->_async_result)) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}

static void
mail_conversation_list_box_add_conversation_item (MailConversationListBox* self,
                                                  CamelFolderInfoFlags folder_info_flags,
                                                  CamelFolderThreadNode* child,
                                                  CamelFolderThread* thread,
                                                  const gchar* service_uid)
{
	MailConversationItemModel* item = NULL;
	MailConversationItemModel* _tmp0_;
	GeeHashMap* _tmp1_;
	CamelMessageInfo* _tmp2_;
	const gchar* _tmp3_;
	const gchar* _tmp4_;
	MailConversationListStore* _tmp5_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (child != NULL);
	g_return_if_fail (thread != NULL);
	g_return_if_fail (service_uid != NULL);
	_tmp0_ = mail_conversation_item_model_new (folder_info_flags, child, thread, service_uid);
	item = _tmp0_;
	_tmp1_ = self->priv->conversations;
	_tmp2_ = child->message;
	_tmp3_ = camel_message_info_get_uid (_tmp2_);
	_tmp4_ = _tmp3_;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp1_, _tmp4_, item);
	_tmp5_ = self->priv->list_store;
	mail_conversation_list_store_add (_tmp5_, item);
	_g_object_unref0 (item);
}

static gboolean
mail_conversation_list_box_filter_function (GObject* obj)
{
	gboolean result;
	g_return_val_if_fail (obj != NULL, FALSE);
	if (MAIL_IS_CONVERSATION_ITEM_MODEL (obj)) {
		gboolean _tmp0_;
		gboolean _tmp1_;
		_tmp0_ = mail_conversation_item_model_get_deleted (G_TYPE_CHECK_INSTANCE_CAST (obj, MAIL_TYPE_CONVERSATION_ITEM_MODEL, MailConversationItemModel));
		_tmp1_ = _tmp0_;
		result = !_tmp1_;
		return result;
	} else {
		result = FALSE;
		return result;
	}
}

static gint
mail_conversation_list_box_thread_sort_function (MailConversationItemModel* item1,
                                                 MailConversationItemModel* item2)
{
	gint64 _tmp0_;
	gint64 _tmp1_;
	gint64 _tmp2_;
	gint64 _tmp3_;
	gint result;
	g_return_val_if_fail (item1 != NULL, 0);
	g_return_val_if_fail (item2 != NULL, 0);
	_tmp0_ = mail_conversation_item_model_get_timestamp (item2);
	_tmp1_ = _tmp0_;
	_tmp2_ = mail_conversation_item_model_get_timestamp (item1);
	_tmp3_ = _tmp2_;
	result = (gint) (_tmp1_ - _tmp3_);
	return result;
}

void
mail_conversation_list_box_mark_read_selected_messages (MailConversationListBox* self)
{
	GeeHashSet* selected_rows = NULL;
	GeeHashSet* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = virtualizing_list_box_get_selected_rows ((VirtualizingListBox*) self);
	selected_rows = _tmp0_;
	{
		GeeIterator* _row_it = NULL;
		GeeHashSet* _tmp1_;
		GeeIterator* _tmp2_;
		_tmp1_ = selected_rows;
		_tmp2_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) _tmp1_);
		_row_it = _tmp2_;
		while (TRUE) {
			GeeIterator* _tmp3_;
			GObject* row = NULL;
			GeeIterator* _tmp4_;
			gpointer _tmp5_;
			GObject* _tmp6_;
			CamelFolderThreadNode* _tmp7_;
			CamelFolderThreadNode* _tmp8_;
			CamelMessageInfo* _tmp9_;
			_tmp3_ = _row_it;
			if (!gee_iterator_next (_tmp3_)) {
				break;
			}
			_tmp4_ = _row_it;
			_tmp5_ = gee_iterator_get (_tmp4_);
			row = (GObject*) _tmp5_;
			_tmp6_ = row;
			_tmp7_ = mail_conversation_item_model_get_node (G_TYPE_CHECK_INSTANCE_CAST (_tmp6_, MAIL_TYPE_CONVERSATION_ITEM_MODEL, MailConversationItemModel));
			_tmp8_ = _tmp7_;
			_tmp9_ = _tmp8_->message;
			camel_message_info_set_flags (_tmp9_, (guint32) CAMEL_MESSAGE_SEEN, (guint32) (~0));
		}
		_g_object_unref0 (_row_it);
	}
	_g_object_unref0 (selected_rows);
}

void
mail_conversation_list_box_mark_star_selected_messages (MailConversationListBox* self)
{
	GeeHashSet* selected_rows = NULL;
	GeeHashSet* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = virtualizing_list_box_get_selected_rows ((VirtualizingListBox*) self);
	selected_rows = _tmp0_;
	{
		GeeIterator* _row_it = NULL;
		GeeHashSet* _tmp1_;
		GeeIterator* _tmp2_;
		_tmp1_ = selected_rows;
		_tmp2_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) _tmp1_);
		_row_it = _tmp2_;
		while (TRUE) {
			GeeIterator* _tmp3_;
			GObject* row = NULL;
			GeeIterator* _tmp4_;
			gpointer _tmp5_;
			GObject* _tmp6_;
			CamelFolderThreadNode* _tmp7_;
			CamelFolderThreadNode* _tmp8_;
			CamelMessageInfo* _tmp9_;
			_tmp3_ = _row_it;
			if (!gee_iterator_next (_tmp3_)) {
				break;
			}
			_tmp4_ = _row_it;
			_tmp5_ = gee_iterator_get (_tmp4_);
			row = (GObject*) _tmp5_;
			_tmp6_ = row;
			_tmp7_ = mail_conversation_item_model_get_node (G_TYPE_CHECK_INSTANCE_CAST (_tmp6_, MAIL_TYPE_CONVERSATION_ITEM_MODEL, MailConversationItemModel));
			_tmp8_ = _tmp7_;
			_tmp9_ = _tmp8_->message;
			camel_message_info_set_flags (_tmp9_, (guint32) CAMEL_MESSAGE_FLAGGED, (guint32) (~0));
		}
		_g_object_unref0 (_row_it);
	}
	_g_object_unref0 (selected_rows);
}

void
mail_conversation_list_box_mark_unread_selected_messages (MailConversationListBox* self)
{
	GeeHashSet* selected_rows = NULL;
	GeeHashSet* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = virtualizing_list_box_get_selected_rows ((VirtualizingListBox*) self);
	selected_rows = _tmp0_;
	{
		GeeIterator* _row_it = NULL;
		GeeHashSet* _tmp1_;
		GeeIterator* _tmp2_;
		_tmp1_ = selected_rows;
		_tmp2_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) _tmp1_);
		_row_it = _tmp2_;
		while (TRUE) {
			GeeIterator* _tmp3_;
			GObject* row = NULL;
			GeeIterator* _tmp4_;
			gpointer _tmp5_;
			GObject* _tmp6_;
			CamelFolderThreadNode* _tmp7_;
			CamelFolderThreadNode* _tmp8_;
			CamelMessageInfo* _tmp9_;
			_tmp3_ = _row_it;
			if (!gee_iterator_next (_tmp3_)) {
				break;
			}
			_tmp4_ = _row_it;
			_tmp5_ = gee_iterator_get (_tmp4_);
			row = (GObject*) _tmp5_;
			_tmp6_ = row;
			_tmp7_ = mail_conversation_item_model_get_node (G_TYPE_CHECK_INSTANCE_CAST (_tmp6_, MAIL_TYPE_CONVERSATION_ITEM_MODEL, MailConversationItemModel));
			_tmp8_ = _tmp7_;
			_tmp9_ = _tmp8_->message;
			camel_message_info_set_flags (_tmp9_, (guint32) CAMEL_MESSAGE_SEEN, (guint32) 0);
		}
		_g_object_unref0 (_row_it);
	}
	_g_object_unref0 (selected_rows);
}

void
mail_conversation_list_box_mark_unstar_selected_messages (MailConversationListBox* self)
{
	GeeHashSet* selected_rows = NULL;
	GeeHashSet* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = virtualizing_list_box_get_selected_rows ((VirtualizingListBox*) self);
	selected_rows = _tmp0_;
	{
		GeeIterator* _row_it = NULL;
		GeeHashSet* _tmp1_;
		GeeIterator* _tmp2_;
		_tmp1_ = selected_rows;
		_tmp2_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) _tmp1_);
		_row_it = _tmp2_;
		while (TRUE) {
			GeeIterator* _tmp3_;
			GObject* row = NULL;
			GeeIterator* _tmp4_;
			gpointer _tmp5_;
			GObject* _tmp6_;
			CamelFolderThreadNode* _tmp7_;
			CamelFolderThreadNode* _tmp8_;
			CamelMessageInfo* _tmp9_;
			_tmp3_ = _row_it;
			if (!gee_iterator_next (_tmp3_)) {
				break;
			}
			_tmp4_ = _row_it;
			_tmp5_ = gee_iterator_get (_tmp4_);
			row = (GObject*) _tmp5_;
			_tmp6_ = row;
			_tmp7_ = mail_conversation_item_model_get_node (G_TYPE_CHECK_INSTANCE_CAST (_tmp6_, MAIL_TYPE_CONVERSATION_ITEM_MODEL, MailConversationItemModel));
			_tmp8_ = _tmp7_;
			_tmp9_ = _tmp8_->message;
			camel_message_info_set_flags (_tmp9_, (guint32) CAMEL_MESSAGE_FLAGGED, (guint32) 0);
		}
		_g_object_unref0 (_row_it);
	}
	_g_object_unref0 (selected_rows);
}

static void
mail_conversation_list_box_archive_selected_messages_data_free (gpointer _data)
{
	MailConversationListBoxArchiveSelectedMessagesData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (MailConversationListBoxArchiveSelectedMessagesData, _data_);
}

void
mail_conversation_list_box_archive_selected_messages (MailConversationListBox* self,
                                                      GAsyncReadyCallback _callback_,
                                                      gpointer _user_data_)
{
	MailConversationListBoxArchiveSelectedMessagesData* _data_;
	MailConversationListBox* _tmp0_;
	g_return_if_fail (self != NULL);
	_data_ = g_slice_new0 (MailConversationListBoxArchiveSelectedMessagesData);
	_data_->_async_result = g_task_new (G_OBJECT (self), NULL, _callback_, _user_data_);
	g_task_set_task_data (_data_->_async_result, _data_, mail_conversation_list_box_archive_selected_messages_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	mail_conversation_list_box_archive_selected_messages_co (_data_);
}

gint
mail_conversation_list_box_archive_selected_messages_finish (MailConversationListBox* self,
                                                             GAsyncResult* _res_)
{
	gint result;
	MailConversationListBoxArchiveSelectedMessagesData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
	result = _data_->result;
	return result;
}

static void
mail_conversation_list_box_archive_selected_messages_ready (GObject* source_object,
                                                            GAsyncResult* _res_,
                                                            gpointer _user_data_)
{
	MailConversationListBoxArchiveSelectedMessagesData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	mail_conversation_list_box_archive_selected_messages_co (_data_);
}

static gboolean
mail_conversation_list_box_archive_selected_messages_co (MailConversationListBoxArchiveSelectedMessagesData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, (GDestroyNotify) g_free, GEE_TYPE_ARRAY_LIST, (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	_data_->archive_threads = _data_->_tmp0_;
	_data_->_tmp1_ = virtualizing_list_box_get_selected_rows ((VirtualizingListBox*) _data_->self);
	_data_->selected_rows = _data_->_tmp1_;
	_data_->_tmp2_ = _data_->self->priv->list_store;
	_data_->_tmp3_ = _data_->selected_rows;
	_data_->_tmp4_ = 0;
	_data_->_tmp5_ = gee_collection_to_array ((GeeCollection*) _data_->_tmp3_, &_data_->_tmp4_);
	_data_->_tmp6_ = _data_->_tmp5_;
	_data_->_tmp6__length1 = _data_->_tmp4_;
	_data_->_tmp7_ = _data_->_tmp6_[0];
	_data_->_tmp8_ = virtualizing_list_box_model_get_index_of ((VirtualizingListBoxModel*) _data_->_tmp2_, _data_->_tmp7_);
	_data_->_tmp6_ = (g_free (_data_->_tmp6_), NULL);
	_data_->selected_rows_start_index = _data_->_tmp8_;
	{
		_data_->_tmp9_ = _data_->selected_rows;
		_data_->_tmp10_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) _data_->_tmp9_);
		_data_->_selected_row_it = _data_->_tmp10_;
		while (TRUE) {
			_data_->_tmp11_ = _data_->_selected_row_it;
			if (!gee_iterator_next (_data_->_tmp11_)) {
				break;
			}
			_data_->_tmp12_ = _data_->_selected_row_it;
			_data_->_tmp13_ = gee_iterator_get (_data_->_tmp12_);
			_data_->selected_row = (GObject*) _data_->_tmp13_;
			_data_->_tmp14_ = _data_->selected_row;
			_data_->_tmp15_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_data_->_tmp14_, MAIL_TYPE_CONVERSATION_ITEM_MODEL, MailConversationItemModel));
			_data_->selected_item_model = _data_->_tmp15_;
			_data_->_tmp16_ = _data_->archive_threads;
			_data_->_tmp17_ = _data_->selected_item_model;
			_data_->_tmp18_ = mail_conversation_item_model_get_service_uid (_data_->_tmp17_);
			_data_->_tmp19_ = _data_->_tmp18_;
			_data_->_tmp20_ = gee_abstract_map_get ((GeeAbstractMap*) _data_->_tmp16_, _data_->_tmp19_);
			_data_->_tmp21_ = (GeeArrayList*) _data_->_tmp20_;
			_data_->_tmp22_ = _data_->_tmp21_ == NULL;
			_g_object_unref0 (_data_->_tmp21_);
			if (_data_->_tmp22_) {
				_data_->_tmp23_ = _data_->archive_threads;
				_data_->_tmp24_ = _data_->selected_item_model;
				_data_->_tmp25_ = mail_conversation_item_model_get_service_uid (_data_->_tmp24_);
				_data_->_tmp26_ = _data_->_tmp25_;
				_data_->_tmp27_ = gee_array_list_new (G_TYPE_POINTER, NULL, NULL, NULL, NULL, NULL);
				_data_->_tmp28_ = _data_->_tmp27_;
				gee_abstract_map_set ((GeeAbstractMap*) _data_->_tmp23_, _data_->_tmp26_, _data_->_tmp28_);
				_g_object_unref0 (_data_->_tmp28_);
			}
			_data_->_tmp29_ = _data_->archive_threads;
			_data_->_tmp30_ = _data_->selected_item_model;
			_data_->_tmp31_ = mail_conversation_item_model_get_service_uid (_data_->_tmp30_);
			_data_->_tmp32_ = _data_->_tmp31_;
			_data_->_tmp33_ = gee_abstract_map_get ((GeeAbstractMap*) _data_->_tmp29_, _data_->_tmp32_);
			_data_->_tmp34_ = (GeeArrayList*) _data_->_tmp33_;
			_data_->_tmp35_ = _data_->selected_item_model;
			_data_->_tmp36_ = mail_conversation_item_model_get_node (_data_->_tmp35_);
			_data_->_tmp37_ = _data_->_tmp36_;
			gee_abstract_collection_add ((GeeAbstractCollection*) _data_->_tmp34_, _data_->_tmp37_);
			_g_object_unref0 (_data_->_tmp34_);
			_g_object_unref0 (_data_->selected_item_model);
		}
		_g_object_unref0 (_data_->_selected_row_it);
	}
	_data_->archived = 0;
	{
		_data_->_tmp38_ = _data_->archive_threads;
		_data_->_tmp39_ = gee_abstract_map_get_keys ((GeeAbstractMap*) _data_->_tmp38_);
		_data_->_tmp40_ = _data_->_tmp39_;
		_data_->_tmp41_ = _data_->_tmp40_;
		_data_->_tmp42_ = gee_iterable_iterator ((GeeIterable*) _data_->_tmp41_);
		_data_->_tmp43_ = _data_->_tmp42_;
		_g_object_unref0 (_data_->_tmp41_);
		_data_->_service_uid_it = _data_->_tmp43_;
		while (TRUE) {
			_data_->_tmp44_ = _data_->_service_uid_it;
			if (!gee_iterator_next (_data_->_tmp44_)) {
				break;
			}
			_data_->_tmp45_ = _data_->_service_uid_it;
			_data_->_tmp46_ = gee_iterator_get (_data_->_tmp45_);
			_data_->service_uid = (gchar*) _data_->_tmp46_;
			_data_->_tmp47_ = _data_->self->priv->move_handler;
			_data_->_tmp48_ = _data_->self->priv->_folders;
			_data_->_tmp49_ = _data_->service_uid;
			_data_->_tmp50_ = gee_abstract_map_get ((GeeAbstractMap*) _data_->_tmp48_, _data_->_tmp49_);
			_data_->_tmp51_ = (CamelFolder*) _data_->_tmp50_;
			_data_->_tmp52_ = _data_->archive_threads;
			_data_->_tmp53_ = _data_->service_uid;
			_data_->_tmp54_ = gee_abstract_map_get ((GeeAbstractMap*) _data_->_tmp52_, _data_->_tmp53_);
			_data_->_tmp55_ = (GeeArrayList*) _data_->_tmp54_;
			_data_->_state_ = 1;
			mail_move_handler_archive_threads (_data_->_tmp47_, _data_->_tmp51_, _data_->_tmp55_, mail_conversation_list_box_archive_selected_messages_ready, _data_);
			return FALSE;
			_state_1:
			_data_->archived += mail_move_handler_archive_threads_finish (_data_->_tmp47_, _data_->_res_);
			_g_object_unref0 (_data_->_tmp55_);
			_g_object_unref0 (_data_->_tmp51_);
			_g_free0 (_data_->service_uid);
		}
		_g_object_unref0 (_data_->_service_uid_it);
	}
	if (_data_->archived > 0) {
		{
			_data_->_tmp56_ = _data_->archive_threads;
			_data_->_tmp57_ = gee_abstract_map_get_keys ((GeeAbstractMap*) _data_->_tmp56_);
			_data_->_tmp58_ = _data_->_tmp57_;
			_data_->_tmp59_ = _data_->_tmp58_;
			_data_->_tmp60_ = gee_iterable_iterator ((GeeIterable*) _data_->_tmp59_);
			_data_->_tmp61_ = _data_->_tmp60_;
			_g_object_unref0 (_data_->_tmp59_);
			_data_->_vala1__service_uid_it = _data_->_tmp61_;
			while (TRUE) {
				_data_->_tmp62_ = _data_->_vala1__service_uid_it;
				if (!gee_iterator_next (_data_->_tmp62_)) {
					break;
				}
				_data_->_tmp63_ = _data_->_vala1__service_uid_it;
				_data_->_tmp64_ = gee_iterator_get (_data_->_tmp63_);
				_data_->_vala1_service_uid = (gchar*) _data_->_tmp64_;
				_data_->_tmp65_ = _data_->archive_threads;
				_data_->_tmp66_ = _data_->_vala1_service_uid;
				_data_->_tmp67_ = gee_abstract_map_get ((GeeAbstractMap*) _data_->_tmp65_, _data_->_tmp66_);
				_data_->threads = (GeeArrayList*) _data_->_tmp67_;
				{
					_data_->_tmp68_ = _data_->threads;
					_data_->_thread_list = _data_->_tmp68_;
					_data_->_tmp69_ = _data_->_thread_list;
					_data_->_tmp70_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _data_->_tmp69_);
					_data_->_tmp71_ = _data_->_tmp70_;
					_data_->_thread_size = _data_->_tmp71_;
					_data_->_thread_index = -1;
					while (TRUE) {
						_data_->_thread_index = _data_->_thread_index + 1;
						_data_->_tmp72_ = _data_->_thread_index;
						_data_->_tmp73_ = _data_->_thread_size;
						if (!(_data_->_tmp72_ < _data_->_tmp73_)) {
							break;
						}
						_data_->_tmp74_ = _data_->_thread_list;
						_data_->_tmp75_ = gee_abstract_list_get ((GeeAbstractList*) _data_->_tmp74_, _data_->_thread_index);
						_data_->thread = (CamelFolderThreadNode*) _data_->_tmp75_;
						_data_->_tmp76_ = _data_->thread;
						_data_->_tmp77_ = _data_->_tmp76_->message;
						_data_->_tmp78_ = camel_message_info_get_uid (_data_->_tmp77_);
						_data_->_tmp79_ = _data_->_tmp78_;
						_data_->uid = _data_->_tmp79_;
						_data_->_tmp80_ = _data_->self->priv->conversations;
						_data_->_tmp81_ = _data_->uid;
						_data_->_tmp82_ = gee_abstract_map_get ((GeeAbstractMap*) _data_->_tmp80_, _data_->_tmp81_);
						_data_->item = (MailConversationItemModel*) _data_->_tmp82_;
						_data_->_tmp83_ = _data_->item;
						if (_data_->_tmp83_ != NULL) {
							_data_->_tmp84_ = _data_->self->priv->conversations;
							_data_->_tmp85_ = _data_->uid;
							gee_abstract_map_unset ((GeeAbstractMap*) _data_->_tmp84_, _data_->_tmp85_, NULL);
							_data_->_tmp86_ = _data_->self->priv->list_store;
							_data_->_tmp87_ = _data_->item;
							mail_conversation_list_store_remove (_data_->_tmp86_, _data_->_tmp87_);
						}
						_g_object_unref0 (_data_->item);
					}
				}
				_g_object_unref0 (_data_->threads);
				_g_free0 (_data_->_vala1_service_uid);
			}
			_g_object_unref0 (_data_->_vala1__service_uid_it);
		}
	}
	_data_->_tmp88_ = _data_->self->priv->list_store;
	_data_->_tmp89_ = _data_->self->priv->list_store;
	g_list_model_items_changed ((GListModel*) _data_->_tmp88_, (guint) 0, (guint) _data_->archived, virtualizing_list_box_model_get_n_items ((VirtualizingListBoxModel*) _data_->_tmp89_));
	virtualizing_list_box_select_row_at_index ((VirtualizingListBox*) _data_->self, _data_->selected_rows_start_index);
	_data_->result = _data_->archived;
	_g_object_unref0 (_data_->selected_rows);
	_g_object_unref0 (_data_->archive_threads);
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (!g_task_get_completed (_data_->_async_result)) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}

gint
mail_conversation_list_box_trash_selected_messages (MailConversationListBox* self)
{
	GeeHashMap* trash_threads = NULL;
	GeeHashMap* _tmp0_;
	GeeHashSet* selected_rows = NULL;
	GeeHashSet* _tmp1_;
	gint selected_rows_start_index = 0;
	MailConversationListStore* _tmp2_;
	GeeHashSet* _tmp3_;
	gint _tmp4_ = 0;
	gpointer* _tmp5_;
	GObject** _tmp6_;
	gint _tmp6__length1;
	GObject* _tmp7_;
	gint _tmp8_;
	gint deleted = 0;
	MailConversationListStore* _tmp56_;
	MailConversationListStore* _tmp57_;
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, (GDestroyNotify) g_free, GEE_TYPE_ARRAY_LIST, (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	trash_threads = _tmp0_;
	_tmp1_ = virtualizing_list_box_get_selected_rows ((VirtualizingListBox*) self);
	selected_rows = _tmp1_;
	_tmp2_ = self->priv->list_store;
	_tmp3_ = selected_rows;
	_tmp5_ = gee_collection_to_array ((GeeCollection*) _tmp3_, &_tmp4_);
	_tmp6_ = _tmp5_;
	_tmp6__length1 = _tmp4_;
	_tmp7_ = _tmp6_[0];
	_tmp8_ = virtualizing_list_box_model_get_index_of ((VirtualizingListBoxModel*) _tmp2_, _tmp7_);
	_tmp6_ = (g_free (_tmp6_), NULL);
	selected_rows_start_index = _tmp8_;
	{
		GeeIterator* _selected_row_it = NULL;
		GeeHashSet* _tmp9_;
		GeeIterator* _tmp10_;
		_tmp9_ = selected_rows;
		_tmp10_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) _tmp9_);
		_selected_row_it = _tmp10_;
		while (TRUE) {
			GeeIterator* _tmp11_;
			GObject* selected_row = NULL;
			GeeIterator* _tmp12_;
			gpointer _tmp13_;
			MailConversationItemModel* selected_item_model = NULL;
			GObject* _tmp14_;
			MailConversationItemModel* _tmp15_;
			GeeHashMap* _tmp16_;
			MailConversationItemModel* _tmp17_;
			const gchar* _tmp18_;
			const gchar* _tmp19_;
			gpointer _tmp20_;
			GeeArrayList* _tmp21_;
			gboolean _tmp22_;
			GeeHashMap* _tmp29_;
			MailConversationItemModel* _tmp30_;
			const gchar* _tmp31_;
			const gchar* _tmp32_;
			gpointer _tmp33_;
			GeeArrayList* _tmp34_;
			MailConversationItemModel* _tmp35_;
			CamelFolderThreadNode* _tmp36_;
			CamelFolderThreadNode* _tmp37_;
			_tmp11_ = _selected_row_it;
			if (!gee_iterator_next (_tmp11_)) {
				break;
			}
			_tmp12_ = _selected_row_it;
			_tmp13_ = gee_iterator_get (_tmp12_);
			selected_row = (GObject*) _tmp13_;
			_tmp14_ = selected_row;
			_tmp15_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp14_, MAIL_TYPE_CONVERSATION_ITEM_MODEL, MailConversationItemModel));
			selected_item_model = _tmp15_;
			_tmp16_ = trash_threads;
			_tmp17_ = selected_item_model;
			_tmp18_ = mail_conversation_item_model_get_service_uid (_tmp17_);
			_tmp19_ = _tmp18_;
			_tmp20_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp16_, _tmp19_);
			_tmp21_ = (GeeArrayList*) _tmp20_;
			_tmp22_ = _tmp21_ == NULL;
			_g_object_unref0 (_tmp21_);
			if (_tmp22_) {
				GeeHashMap* _tmp23_;
				MailConversationItemModel* _tmp24_;
				const gchar* _tmp25_;
				const gchar* _tmp26_;
				GeeArrayList* _tmp27_;
				GeeArrayList* _tmp28_;
				_tmp23_ = trash_threads;
				_tmp24_ = selected_item_model;
				_tmp25_ = mail_conversation_item_model_get_service_uid (_tmp24_);
				_tmp26_ = _tmp25_;
				_tmp27_ = gee_array_list_new (G_TYPE_POINTER, NULL, NULL, NULL, NULL, NULL);
				_tmp28_ = _tmp27_;
				gee_abstract_map_set ((GeeAbstractMap*) _tmp23_, _tmp26_, _tmp28_);
				_g_object_unref0 (_tmp28_);
			}
			_tmp29_ = trash_threads;
			_tmp30_ = selected_item_model;
			_tmp31_ = mail_conversation_item_model_get_service_uid (_tmp30_);
			_tmp32_ = _tmp31_;
			_tmp33_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp29_, _tmp32_);
			_tmp34_ = (GeeArrayList*) _tmp33_;
			_tmp35_ = selected_item_model;
			_tmp36_ = mail_conversation_item_model_get_node (_tmp35_);
			_tmp37_ = _tmp36_;
			gee_abstract_collection_add ((GeeAbstractCollection*) _tmp34_, _tmp37_);
			_g_object_unref0 (_tmp34_);
			_g_object_unref0 (selected_item_model);
		}
		_g_object_unref0 (_selected_row_it);
	}
	deleted = 0;
	{
		GeeIterator* _service_uid_it = NULL;
		GeeHashMap* _tmp38_;
		GeeSet* _tmp39_;
		GeeSet* _tmp40_;
		GeeSet* _tmp41_;
		GeeIterator* _tmp42_;
		GeeIterator* _tmp43_;
		_tmp38_ = trash_threads;
		_tmp39_ = gee_abstract_map_get_keys ((GeeAbstractMap*) _tmp38_);
		_tmp40_ = _tmp39_;
		_tmp41_ = _tmp40_;
		_tmp42_ = gee_iterable_iterator ((GeeIterable*) _tmp41_);
		_tmp43_ = _tmp42_;
		_g_object_unref0 (_tmp41_);
		_service_uid_it = _tmp43_;
		while (TRUE) {
			GeeIterator* _tmp44_;
			gchar* service_uid = NULL;
			GeeIterator* _tmp45_;
			gpointer _tmp46_;
			MailMoveHandler* _tmp47_;
			GeeHashMap* _tmp48_;
			const gchar* _tmp49_;
			gpointer _tmp50_;
			CamelFolder* _tmp51_;
			GeeHashMap* _tmp52_;
			const gchar* _tmp53_;
			gpointer _tmp54_;
			GeeArrayList* _tmp55_;
			_tmp44_ = _service_uid_it;
			if (!gee_iterator_next (_tmp44_)) {
				break;
			}
			_tmp45_ = _service_uid_it;
			_tmp46_ = gee_iterator_get (_tmp45_);
			service_uid = (gchar*) _tmp46_;
			_tmp47_ = self->priv->move_handler;
			_tmp48_ = self->priv->_folders;
			_tmp49_ = service_uid;
			_tmp50_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp48_, _tmp49_);
			_tmp51_ = (CamelFolder*) _tmp50_;
			_tmp52_ = trash_threads;
			_tmp53_ = service_uid;
			_tmp54_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp52_, _tmp53_);
			_tmp55_ = (GeeArrayList*) _tmp54_;
			deleted += mail_move_handler_delete_threads (_tmp47_, _tmp51_, _tmp55_);
			_g_object_unref0 (_tmp55_);
			_g_object_unref0 (_tmp51_);
			_g_free0 (service_uid);
		}
		_g_object_unref0 (_service_uid_it);
	}
	_tmp56_ = self->priv->list_store;
	_tmp57_ = self->priv->list_store;
	g_list_model_items_changed ((GListModel*) _tmp56_, (guint) 0, (guint) 0, virtualizing_list_box_model_get_n_items ((VirtualizingListBoxModel*) _tmp57_));
	virtualizing_list_box_select_row_at_index ((VirtualizingListBox*) self, selected_rows_start_index + 1);
	result = deleted;
	_g_object_unref0 (selected_rows);
	_g_object_unref0 (trash_threads);
	return result;
}

static void
__lambda26_ (MailConversationListBox* self,
             GObject* obj,
             GAsyncResult* res)
{
	MailMoveHandler* _tmp0_;
	MailConversationListStore* _tmp1_;
	MailConversationListStore* _tmp2_;
	g_return_if_fail (res != NULL);
	_tmp0_ = self->priv->move_handler;
	mail_move_handler_undo_last_move_finish (_tmp0_, res);
	_tmp1_ = self->priv->list_store;
	_tmp2_ = self->priv->list_store;
	g_list_model_items_changed ((GListModel*) _tmp1_, (guint) 0, (guint) 0, virtualizing_list_box_model_get_n_items ((VirtualizingListBoxModel*) _tmp2_));
}

static void
___lambda26__gasync_ready_callback (GObject* source_object,
                                    GAsyncResult* res,
                                    gpointer self)
{
	__lambda26_ ((MailConversationListBox*) self, source_object, res);
	g_object_unref (self);
}

void
mail_conversation_list_box_undo_move (MailConversationListBox* self)
{
	MailMoveHandler* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->move_handler;
	mail_move_handler_undo_last_move (_tmp0_, ___lambda26__gasync_ready_callback, g_object_ref (self));
}

void
mail_conversation_list_box_undo_expired (MailConversationListBox* self)
{
	MailMoveHandler* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->move_handler;
	mail_move_handler_expire_undo (_tmp0_);
}

static void
__lambda27_ (MailConversationListBox* self)
{
	mail_conversation_list_box_trash_selected_messages (self);
}

static void
___lambda27__gtk_menu_item_activate (GtkMenuItem* _sender,
                                     gpointer self)
{
	__lambda27_ ((MailConversationListBox*) self);
}

static void
___lambda28_ (MailConversationListBox* self)
{
	mail_conversation_list_box_mark_unread_selected_messages (self);
}

static void
____lambda28__gtk_menu_item_activate (GtkMenuItem* _sender,
                                      gpointer self)
{
	___lambda28_ ((MailConversationListBox*) self);
}

static void
___lambda29_ (MailConversationListBox* self)
{
	mail_conversation_list_box_mark_read_selected_messages (self);
}

static void
____lambda29__gtk_menu_item_activate (GtkMenuItem* _sender,
                                      gpointer self)
{
	___lambda29_ ((MailConversationListBox*) self);
}

static void
___lambda30_ (MailConversationListBox* self)
{
	mail_conversation_list_box_mark_star_selected_messages (self);
}

static void
____lambda30__gtk_menu_item_activate (GtkMenuItem* _sender,
                                      gpointer self)
{
	___lambda30_ ((MailConversationListBox*) self);
}

static void
___lambda31_ (MailConversationListBox* self)
{
	mail_conversation_list_box_mark_unstar_selected_messages (self);
}

static void
____lambda31__gtk_menu_item_activate (GtkMenuItem* _sender,
                                      gpointer self)
{
	___lambda31_ ((MailConversationListBox*) self);
}

static gboolean
mail_conversation_list_box_create_context_menu (MailConversationListBox* self,
                                                GdkEvent* e,
                                                MailConversationListItem* row)
{
	MailConversationItemModel* item = NULL;
	GObject* _tmp0_;
	GObject* _tmp1_;
	MailConversationItemModel* _tmp2_;
	GtkMenu* menu = NULL;
	GtkMenu* _tmp3_;
	GtkMenuItem* trash_menu_item = NULL;
	GtkMenuItem* _tmp4_;
	GtkMenuItem* _tmp5_;
	GraniteAccelLabel* _tmp6_;
	GraniteAccelLabel* _tmp7_;
	GtkMenu* _tmp8_;
	GtkMenuItem* _tmp9_;
	GtkMenuItem* _tmp10_;
	MailConversationItemModel* _tmp11_;
	gboolean _tmp12_;
	gboolean _tmp13_;
	MailConversationItemModel* _tmp28_;
	gboolean _tmp29_;
	gboolean _tmp30_;
	GtkMenu* _tmp45_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (e != NULL, FALSE);
	g_return_val_if_fail (row != NULL, FALSE);
	_tmp0_ = virtualizing_list_box_row_get_model_item ((VirtualizingListBoxRow*) row);
	_tmp1_ = _tmp0_;
	_tmp2_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp1_, MAIL_TYPE_CONVERSATION_ITEM_MODEL, MailConversationItemModel));
	item = _tmp2_;
	_tmp3_ = (GtkMenu*) gtk_menu_new ();
	g_object_ref_sink (_tmp3_);
	menu = _tmp3_;
	_tmp4_ = (GtkMenuItem*) gtk_menu_item_new ();
	g_object_ref_sink (_tmp4_);
	trash_menu_item = _tmp4_;
	_tmp5_ = trash_menu_item;
	_tmp6_ = granite_accel_label_new_from_action_name (_ ("Move To Trash"), MAIL_MAIN_WINDOW_ACTION_PREFIX MAIL_MAIN_WINDOW_ACTION_MOVE_TO_TRASH);
	g_object_ref_sink (_tmp6_);
	_tmp7_ = _tmp6_;
	gtk_container_add ((GtkContainer*) _tmp5_, (GtkWidget*) _tmp7_);
	_g_object_unref0 (_tmp7_);
	_tmp8_ = menu;
	_tmp9_ = trash_menu_item;
	gtk_container_add ((GtkContainer*) _tmp8_, (GtkWidget*) _tmp9_);
	_tmp10_ = trash_menu_item;
	g_signal_connect_object (_tmp10_, "activate", (GCallback) ___lambda27__gtk_menu_item_activate, self, 0);
	_tmp11_ = item;
	_tmp12_ = mail_conversation_item_model_get_unread (_tmp11_);
	_tmp13_ = _tmp12_;
	if (!_tmp13_) {
		GtkMenuItem* mark_unread_menu_item = NULL;
		GtkMenuItem* _tmp14_;
		GtkMenuItem* _tmp15_;
		GraniteAccelLabel* _tmp16_;
		GraniteAccelLabel* _tmp17_;
		GtkMenu* _tmp18_;
		GtkMenuItem* _tmp19_;
		GtkMenuItem* _tmp20_;
		_tmp14_ = (GtkMenuItem*) gtk_menu_item_new ();
		g_object_ref_sink (_tmp14_);
		mark_unread_menu_item = _tmp14_;
		_tmp15_ = mark_unread_menu_item;
		_tmp16_ = granite_accel_label_new_from_action_name (_ ("Mark As Unread"), MAIL_MAIN_WINDOW_ACTION_PREFIX MAIL_MAIN_WINDOW_ACTION_MARK_UNREAD);
		g_object_ref_sink (_tmp16_);
		_tmp17_ = _tmp16_;
		gtk_container_add ((GtkContainer*) _tmp15_, (GtkWidget*) _tmp17_);
		_g_object_unref0 (_tmp17_);
		_tmp18_ = menu;
		_tmp19_ = mark_unread_menu_item;
		gtk_container_add ((GtkContainer*) _tmp18_, (GtkWidget*) _tmp19_);
		_tmp20_ = mark_unread_menu_item;
		g_signal_connect_object (_tmp20_, "activate", (GCallback) ____lambda28__gtk_menu_item_activate, self, 0);
		_g_object_unref0 (mark_unread_menu_item);
	} else {
		GtkMenuItem* mark_read_menu_item = NULL;
		GtkMenuItem* _tmp21_;
		GtkMenuItem* _tmp22_;
		GraniteAccelLabel* _tmp23_;
		GraniteAccelLabel* _tmp24_;
		GtkMenu* _tmp25_;
		GtkMenuItem* _tmp26_;
		GtkMenuItem* _tmp27_;
		_tmp21_ = (GtkMenuItem*) gtk_menu_item_new ();
		g_object_ref_sink (_tmp21_);
		mark_read_menu_item = _tmp21_;
		_tmp22_ = mark_read_menu_item;
		_tmp23_ = granite_accel_label_new_from_action_name (_ ("Mark as Read"), MAIL_MAIN_WINDOW_ACTION_PREFIX MAIL_MAIN_WINDOW_ACTION_MARK_READ);
		g_object_ref_sink (_tmp23_);
		_tmp24_ = _tmp23_;
		gtk_container_add ((GtkContainer*) _tmp22_, (GtkWidget*) _tmp24_);
		_g_object_unref0 (_tmp24_);
		_tmp25_ = menu;
		_tmp26_ = mark_read_menu_item;
		gtk_container_add ((GtkContainer*) _tmp25_, (GtkWidget*) _tmp26_);
		_tmp27_ = mark_read_menu_item;
		g_signal_connect_object (_tmp27_, "activate", (GCallback) ____lambda29__gtk_menu_item_activate, self, 0);
		_g_object_unref0 (mark_read_menu_item);
	}
	_tmp28_ = item;
	_tmp29_ = mail_conversation_item_model_get_flagged (_tmp28_);
	_tmp30_ = _tmp29_;
	if (!_tmp30_) {
		GtkMenuItem* mark_starred_menu_item = NULL;
		GtkMenuItem* _tmp31_;
		GtkMenuItem* _tmp32_;
		GraniteAccelLabel* _tmp33_;
		GraniteAccelLabel* _tmp34_;
		GtkMenu* _tmp35_;
		GtkMenuItem* _tmp36_;
		GtkMenuItem* _tmp37_;
		_tmp31_ = (GtkMenuItem*) gtk_menu_item_new ();
		g_object_ref_sink (_tmp31_);
		mark_starred_menu_item = _tmp31_;
		_tmp32_ = mark_starred_menu_item;
		_tmp33_ = granite_accel_label_new_from_action_name (_ ("Star"), MAIL_MAIN_WINDOW_ACTION_PREFIX MAIL_MAIN_WINDOW_ACTION_MARK_STAR);
		g_object_ref_sink (_tmp33_);
		_tmp34_ = _tmp33_;
		gtk_container_add ((GtkContainer*) _tmp32_, (GtkWidget*) _tmp34_);
		_g_object_unref0 (_tmp34_);
		_tmp35_ = menu;
		_tmp36_ = mark_starred_menu_item;
		gtk_container_add ((GtkContainer*) _tmp35_, (GtkWidget*) _tmp36_);
		_tmp37_ = mark_starred_menu_item;
		g_signal_connect_object (_tmp37_, "activate", (GCallback) ____lambda30__gtk_menu_item_activate, self, 0);
		_g_object_unref0 (mark_starred_menu_item);
	} else {
		GtkMenuItem* mark_unstarred_menu_item = NULL;
		GtkMenuItem* _tmp38_;
		GtkMenuItem* _tmp39_;
		GraniteAccelLabel* _tmp40_;
		GraniteAccelLabel* _tmp41_;
		GtkMenu* _tmp42_;
		GtkMenuItem* _tmp43_;
		GtkMenuItem* _tmp44_;
		_tmp38_ = (GtkMenuItem*) gtk_menu_item_new ();
		g_object_ref_sink (_tmp38_);
		mark_unstarred_menu_item = _tmp38_;
		_tmp39_ = mark_unstarred_menu_item;
		_tmp40_ = granite_accel_label_new_from_action_name (_ ("Unstar"), MAIL_MAIN_WINDOW_ACTION_PREFIX MAIL_MAIN_WINDOW_ACTION_MARK_UNSTAR);
		g_object_ref_sink (_tmp40_);
		_tmp41_ = _tmp40_;
		gtk_container_add ((GtkContainer*) _tmp39_, (GtkWidget*) _tmp41_);
		_g_object_unref0 (_tmp41_);
		_tmp42_ = menu;
		_tmp43_ = mark_unstarred_menu_item;
		gtk_container_add ((GtkContainer*) _tmp42_, (GtkWidget*) _tmp43_);
		_tmp44_ = mark_unstarred_menu_item;
		g_signal_connect_object (_tmp44_, "activate", (GCallback) ____lambda31__gtk_menu_item_activate, self, 0);
		_g_object_unref0 (mark_unstarred_menu_item);
	}
	_tmp45_ = menu;
	gtk_widget_show_all ((GtkWidget*) _tmp45_);
	if (e->type == GDK_BUTTON_RELEASE) {
		GtkMenu* _tmp46_;
		_tmp46_ = menu;
		gtk_menu_popup_at_pointer (_tmp46_, e);
		result = GDK_EVENT_STOP;
		_g_object_unref0 (trash_menu_item);
		_g_object_unref0 (menu);
		_g_object_unref0 (item);
		return result;
	} else {
		if (e->type == GDK_KEY_RELEASE) {
			GtkMenu* _tmp47_;
			_tmp47_ = menu;
			gtk_menu_popup_at_widget (_tmp47_, (GtkWidget*) row, GDK_GRAVITY_EAST, GDK_GRAVITY_CENTER, e);
			result = GDK_EVENT_STOP;
			_g_object_unref0 (trash_menu_item);
			_g_object_unref0 (menu);
			_g_object_unref0 (item);
			return result;
		}
	}
	result = GDK_EVENT_PROPAGATE;
	_g_object_unref0 (trash_menu_item);
	_g_object_unref0 (menu);
	_g_object_unref0 (item);
	return result;
}

MailConversationListBox*
mail_conversation_list_box_construct (GType object_type)
{
	MailConversationListBox * self = NULL;
	self = (MailConversationListBox*) virtualizing_list_box_construct (object_type);
	return self;
}

MailConversationListBox*
mail_conversation_list_box_new (void)
{
	return mail_conversation_list_box_construct (MAIL_TYPE_CONVERSATION_LIST_BOX);
}

GeeMap*
mail_conversation_list_box_get_folder_full_name_per_account (MailConversationListBox* self)
{
	GeeMap* result;
	GeeMap* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_folder_full_name_per_account;
	result = _tmp0_;
	return result;
}

static void
mail_conversation_list_box_set_folder_full_name_per_account (MailConversationListBox* self,
                                                             GeeMap* value)
{
	GeeMap* old_value;
	g_return_if_fail (self != NULL);
	old_value = mail_conversation_list_box_get_folder_full_name_per_account (self);
	if (old_value != value) {
		GeeMap* _tmp0_;
		_tmp0_ = _g_object_ref0 (value);
		_g_object_unref0 (self->priv->_folder_full_name_per_account);
		self->priv->_folder_full_name_per_account = _tmp0_;
		g_object_notify_by_pspec ((GObject *) self, mail_conversation_list_box_properties[MAIL_CONVERSATION_LIST_BOX_FOLDER_FULL_NAME_PER_ACCOUNT_PROPERTY]);
	}
}

GeeHashMap*
mail_conversation_list_box_get_folders (MailConversationListBox* self)
{
	GeeHashMap* result;
	GeeHashMap* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_folders;
	result = _tmp0_;
	return result;
}

static void
mail_conversation_list_box_set_folders (MailConversationListBox* self,
                                        GeeHashMap* value)
{
	GeeHashMap* old_value;
	g_return_if_fail (self != NULL);
	old_value = mail_conversation_list_box_get_folders (self);
	if (old_value != value) {
		GeeHashMap* _tmp0_;
		_tmp0_ = _g_object_ref0 (value);
		_g_object_unref0 (self->priv->_folders);
		self->priv->_folders = _tmp0_;
		g_object_notify_by_pspec ((GObject *) self, mail_conversation_list_box_properties[MAIL_CONVERSATION_LIST_BOX_FOLDERS_PROPERTY]);
	}
}

GeeHashMap*
mail_conversation_list_box_get_folder_info_flags (MailConversationListBox* self)
{
	GeeHashMap* result;
	GeeHashMap* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_folder_info_flags;
	result = _tmp0_;
	return result;
}

static void
mail_conversation_list_box_set_folder_info_flags (MailConversationListBox* self,
                                                  GeeHashMap* value)
{
	GeeHashMap* old_value;
	g_return_if_fail (self != NULL);
	old_value = mail_conversation_list_box_get_folder_info_flags (self);
	if (old_value != value) {
		GeeHashMap* _tmp0_;
		_tmp0_ = _g_object_ref0 (value);
		_g_object_unref0 (self->priv->_folder_info_flags);
		self->priv->_folder_info_flags = _tmp0_;
		g_object_notify_by_pspec ((GObject *) self, mail_conversation_list_box_properties[MAIL_CONVERSATION_LIST_BOX_FOLDER_INFO_FLAGS_PROPERTY]);
	}
}

static gint
_mail_conversation_list_box_thread_sort_function_gcompare_data_func (gconstpointer a,
                                                                     gconstpointer b,
                                                                     gpointer self)
{
	gint result;
	result = mail_conversation_list_box_thread_sort_function ((MailConversationItemModel*) a, (MailConversationItemModel*) b);
	return result;
}

static gboolean
_mail_conversation_list_box_filter_function_mail_conversation_list_store_row_visibility_func (GObject* row,
                                                                                              gpointer self)
{
	gboolean result;
	result = mail_conversation_list_box_filter_function (row);
	return result;
}

static VirtualizingListBoxRow*
_mail_conversation_list_box___lambda32_ (MailConversationListBox* self,
                                         GObject* item,
                                         VirtualizingListBoxRow* old_widget)
{
	MailConversationListItem* row = NULL;
	MailConversationListItem* _tmp2_;
	MailConversationListItem* _tmp3_;
	VirtualizingListBoxRow* result;
	g_return_val_if_fail (item != NULL, NULL);
	row = NULL;
	if (old_widget != NULL) {
		MailConversationListItem* _tmp0_;
		_tmp0_ = _g_object_ref0 (MAIL_IS_CONVERSATION_LIST_ITEM (old_widget) ? ((MailConversationListItem*) old_widget) : NULL);
		_g_object_unref0 (row);
		row = _tmp0_;
	} else {
		MailConversationListItem* _tmp1_;
		_tmp1_ = mail_conversation_list_item_new ();
		g_object_ref_sink (_tmp1_);
		_g_object_unref0 (row);
		row = _tmp1_;
	}
	_tmp2_ = row;
	mail_conversation_list_item_assign (_tmp2_, G_TYPE_CHECK_INSTANCE_CAST (item, MAIL_TYPE_CONVERSATION_ITEM_MODEL, MailConversationItemModel));
	_tmp3_ = row;
	gtk_widget_show_all ((GtkWidget*) _tmp3_);
	result = (VirtualizingListBoxRow*) row;
	return result;
}

static VirtualizingListBoxRow*
__mail_conversation_list_box___lambda32__virtualizing_list_box_row_factory_method (GObject* item,
                                                                                   VirtualizingListBoxRow* old_widget,
                                                                                   gpointer self)
{
	VirtualizingListBoxRow* result;
	result = _mail_conversation_list_box___lambda32_ ((MailConversationListBox*) self, item, old_widget);
	return result;
}

static Block22Data*
block22_data_ref (Block22Data* _data22_)
{
	g_atomic_int_inc (&_data22_->_ref_count_);
	return _data22_;
}

static void
block22_data_unref (void * _userdata_)
{
	Block22Data* _data22_;
	_data22_ = (Block22Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data22_->_ref_count_)) {
		MailConversationListBox* self;
		self = _data22_->self;
		_g_object_unref0 (_data22_->row);
		_g_object_unref0 (self);
		g_slice_free (Block22Data, _data22_);
	}
}

static gboolean
____lambda34_ (Block22Data* _data22_)
{
	MailConversationListBox* self;
	CamelFolderThreadNode* _tmp0_;
	CamelFolderThreadNode* _tmp1_;
	gboolean result;
	self = _data22_->self;
	_tmp0_ = mail_conversation_item_model_get_node (G_TYPE_CHECK_INSTANCE_CAST (_data22_->row, MAIL_TYPE_CONVERSATION_ITEM_MODEL, MailConversationItemModel));
	_tmp1_ = _tmp0_;
	mail_conversation_list_box_set_thread_flag (_tmp1_, CAMEL_MESSAGE_SEEN);
	self->priv->mark_read_timeout_id = (guint) 0;
	result = FALSE;
	return result;
}

static gboolean
_____lambda34__gsource_func (gpointer self)
{
	gboolean result;
	result = ____lambda34_ (self);
	return result;
}

static void
_mail_conversation_list_box___lambda33_ (MailConversationListBox* self,
                                         GObject* row)
{
	Block22Data* _data22_;
	GObject* _tmp0_;
	g_return_if_fail (row != NULL);
	_data22_ = g_slice_new0 (Block22Data);
	_data22_->_ref_count_ = 1;
	_data22_->self = g_object_ref (self);
	_tmp0_ = _g_object_ref0 (row);
	_g_object_unref0 (_data22_->row);
	_data22_->row = _tmp0_;
	if (self->priv->mark_read_timeout_id != ((guint) 0)) {
		g_source_remove (self->priv->mark_read_timeout_id);
		self->priv->mark_read_timeout_id = (guint) 0;
	}
	if (_data22_->row == NULL) {
		g_signal_emit (self, mail_conversation_list_box_signals[MAIL_CONVERSATION_LIST_BOX_CONVERSATION_FOCUSED_SIGNAL], 0, NULL);
	} else {
		CamelFolderThreadNode* _tmp1_;
		CamelFolderThreadNode* _tmp2_;
		gboolean _tmp3_;
		gboolean _tmp4_;
		_tmp1_ = mail_conversation_item_model_get_node (G_TYPE_CHECK_INSTANCE_CAST (_data22_->row, MAIL_TYPE_CONVERSATION_ITEM_MODEL, MailConversationItemModel));
		_tmp2_ = _tmp1_;
		g_signal_emit (self, mail_conversation_list_box_signals[MAIL_CONVERSATION_LIST_BOX_CONVERSATION_FOCUSED_SIGNAL], 0, _tmp2_);
		_tmp3_ = mail_conversation_item_model_get_unread (G_TYPE_CHECK_INSTANCE_CAST (_data22_->row, MAIL_TYPE_CONVERSATION_ITEM_MODEL, MailConversationItemModel));
		_tmp4_ = _tmp3_;
		if (_tmp4_) {
			self->priv->mark_read_timeout_id = g_timeout_add_seconds_full (G_PRIORITY_DEFAULT, (guint) MAIL_CONVERSATION_LIST_BOX_MARK_READ_TIMEOUT_SECONDS, _____lambda34__gsource_func, block22_data_ref (_data22_), block22_data_unref);
		}
	}
	block22_data_unref (_data22_);
	_data22_ = NULL;
}

static void
__mail_conversation_list_box___lambda33__virtualizing_list_box_row_activated (VirtualizingListBox* _sender,
                                                                              GObject* row,
                                                                              gpointer self)
{
	_mail_conversation_list_box___lambda33_ ((MailConversationListBox*) self, row);
}

static void
_mail_conversation_list_box___lambda35_ (MailConversationListBox* self,
                                         GObject* row)
{
	g_return_if_fail (row != NULL);
	if (row == NULL) {
		g_signal_emit (self, mail_conversation_list_box_signals[MAIL_CONVERSATION_LIST_BOX_CONVERSATION_SELECTED_SIGNAL], 0, NULL);
	} else {
		GtkApplicationWindow* window = NULL;
		GtkWidget* _tmp0_;
		GtkApplicationWindow* _tmp1_;
		GActionMap* win_action_map = NULL;
		GtkApplicationWindow* _tmp2_;
		GActionGroup* _tmp3_;
		GActionMap* _tmp4_;
		GAction* _tmp5_;
		gboolean _tmp6_;
		gboolean _tmp7_;
		GActionMap* _tmp8_;
		GAction* _tmp9_;
		gboolean _tmp10_;
		gboolean _tmp11_;
		GActionMap* _tmp12_;
		GAction* _tmp13_;
		gboolean _tmp14_;
		gboolean _tmp15_;
		GActionMap* _tmp16_;
		GAction* _tmp17_;
		gboolean _tmp18_;
		gboolean _tmp19_;
		CamelFolderThreadNode* _tmp20_;
		CamelFolderThreadNode* _tmp21_;
		_tmp0_ = gtk_widget_get_toplevel ((GtkWidget*) self);
		_tmp1_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp0_, gtk_application_window_get_type (), GtkApplicationWindow));
		window = _tmp1_;
		_tmp2_ = window;
		_tmp3_ = gtk_widget_get_action_group ((GtkWidget*) _tmp2_, MAIL_MAIN_WINDOW_ACTION_GROUP_PREFIX);
		win_action_map = G_TYPE_CHECK_INSTANCE_CAST (_tmp3_, g_action_map_get_type (), GActionMap);
		_tmp4_ = win_action_map;
		_tmp5_ = g_action_map_lookup_action (_tmp4_, MAIL_MAIN_WINDOW_ACTION_MARK_READ);
		_tmp6_ = mail_conversation_item_model_get_unread (G_TYPE_CHECK_INSTANCE_CAST (row, MAIL_TYPE_CONVERSATION_ITEM_MODEL, MailConversationItemModel));
		_tmp7_ = _tmp6_;
		g_simple_action_set_enabled (G_TYPE_CHECK_INSTANCE_CAST (_tmp5_, g_simple_action_get_type (), GSimpleAction), _tmp7_);
		_tmp8_ = win_action_map;
		_tmp9_ = g_action_map_lookup_action (_tmp8_, MAIL_MAIN_WINDOW_ACTION_MARK_UNREAD);
		_tmp10_ = mail_conversation_item_model_get_unread (G_TYPE_CHECK_INSTANCE_CAST (row, MAIL_TYPE_CONVERSATION_ITEM_MODEL, MailConversationItemModel));
		_tmp11_ = _tmp10_;
		g_simple_action_set_enabled (G_TYPE_CHECK_INSTANCE_CAST (_tmp9_, g_simple_action_get_type (), GSimpleAction), !_tmp11_);
		_tmp12_ = win_action_map;
		_tmp13_ = g_action_map_lookup_action (_tmp12_, MAIL_MAIN_WINDOW_ACTION_MARK_STAR);
		_tmp14_ = mail_conversation_item_model_get_flagged (G_TYPE_CHECK_INSTANCE_CAST (row, MAIL_TYPE_CONVERSATION_ITEM_MODEL, MailConversationItemModel));
		_tmp15_ = _tmp14_;
		g_simple_action_set_enabled (G_TYPE_CHECK_INSTANCE_CAST (_tmp13_, g_simple_action_get_type (), GSimpleAction), !_tmp15_);
		_tmp16_ = win_action_map;
		_tmp17_ = g_action_map_lookup_action (_tmp16_, MAIL_MAIN_WINDOW_ACTION_MARK_UNSTAR);
		_tmp18_ = mail_conversation_item_model_get_flagged (G_TYPE_CHECK_INSTANCE_CAST (row, MAIL_TYPE_CONVERSATION_ITEM_MODEL, MailConversationItemModel));
		_tmp19_ = _tmp18_;
		g_simple_action_set_enabled (G_TYPE_CHECK_INSTANCE_CAST (_tmp17_, g_simple_action_get_type (), GSimpleAction), _tmp19_);
		_tmp20_ = mail_conversation_item_model_get_node (G_TYPE_CHECK_INSTANCE_CAST (row, MAIL_TYPE_CONVERSATION_ITEM_MODEL, MailConversationItemModel));
		_tmp21_ = _tmp20_;
		g_signal_emit (self, mail_conversation_list_box_signals[MAIL_CONVERSATION_LIST_BOX_CONVERSATION_SELECTED_SIGNAL], 0, _tmp21_);
		_g_object_unref0 (window);
	}
}

static void
__mail_conversation_list_box___lambda35__virtualizing_list_box_row_selected (VirtualizingListBox* _sender,
                                                                             GObject* row,
                                                                             gpointer self)
{
	_mail_conversation_list_box___lambda35_ ((MailConversationListBox*) self, row);
}

static gboolean
_mail_conversation_list_box___lambda36_ (MailConversationListBox* self,
                                         GdkEventButton* e)
{
	VirtualizingListBoxRow* row = NULL;
	VirtualizingListBoxRow* _tmp0_;
	VirtualizingListBoxRow* _tmp1_;
	VirtualizingListBoxRow* _tmp2_;
	VirtualizingListBoxRow* _tmp3_;
	VirtualizingListBoxRow* _tmp4_;
	VirtualizingListBoxRow* _tmp6_;
	gboolean result;
	g_return_val_if_fail (e != NULL, FALSE);
	if (e->button != ((guint) GDK_BUTTON_SECONDARY)) {
		result = GDK_EVENT_PROPAGATE;
		return result;
	}
	_tmp0_ = virtualizing_list_box_get_row_at_y ((VirtualizingListBox*) self, (gint) e->y);
	_tmp1_ = _g_object_ref0 (_tmp0_);
	row = _tmp1_;
	_tmp2_ = virtualizing_list_box_get_selected_row_widget ((VirtualizingListBox*) self);
	_tmp3_ = _tmp2_;
	_tmp4_ = row;
	if (_tmp3_ != _tmp4_) {
		VirtualizingListBoxRow* _tmp5_;
		_tmp5_ = row;
		virtualizing_list_box_select_row ((VirtualizingListBox*) self, _tmp5_);
	}
	_tmp6_ = row;
	result = mail_conversation_list_box_create_context_menu (self, (GdkEvent*) e, G_TYPE_CHECK_INSTANCE_CAST (_tmp6_, MAIL_TYPE_CONVERSATION_LIST_ITEM, MailConversationListItem));
	_g_object_unref0 (row);
	return result;
}

static gboolean
__mail_conversation_list_box___lambda36__gtk_widget_button_release_event (GtkWidget* _sender,
                                                                          GdkEventButton* event,
                                                                          gpointer self)
{
	gboolean result;
	result = _mail_conversation_list_box___lambda36_ ((MailConversationListBox*) self, event);
	return result;
}

static gboolean
_mail_conversation_list_box___lambda37_ (MailConversationListBox* self,
                                         GdkEventKey* e)
{
	VirtualizingListBoxRow* row = NULL;
	VirtualizingListBoxRow* _tmp0_;
	VirtualizingListBoxRow* _tmp1_;
	VirtualizingListBoxRow* _tmp2_;
	VirtualizingListBoxRow* _tmp3_;
	gboolean result;
	g_return_val_if_fail (e != NULL, FALSE);
	if (e->keyval != GDK_KEY_Menu) {
		result = GDK_EVENT_PROPAGATE;
		return result;
	}
	_tmp0_ = virtualizing_list_box_get_selected_row_widget ((VirtualizingListBox*) self);
	_tmp1_ = _tmp0_;
	_tmp2_ = _g_object_ref0 (_tmp1_);
	row = _tmp2_;
	_tmp3_ = row;
	result = mail_conversation_list_box_create_context_menu (self, (GdkEvent*) e, G_TYPE_CHECK_INSTANCE_CAST (_tmp3_, MAIL_TYPE_CONVERSATION_LIST_ITEM, MailConversationListItem));
	_g_object_unref0 (row);
	return result;
}

static gboolean
__mail_conversation_list_box___lambda37__gtk_widget_key_release_event (GtkWidget* _sender,
                                                                       GdkEventKey* event,
                                                                       gpointer self)
{
	gboolean result;
	result = _mail_conversation_list_box___lambda37_ ((MailConversationListBox*) self, event);
	return result;
}

static GObject *
mail_conversation_list_box_constructor (GType type,
                                        guint n_construct_properties,
                                        GObjectConstructParam * construct_properties)
{
	GObject * obj;
	GObjectClass * parent_class;
	MailConversationListBox * self;
	GeeHashMap* _tmp0_;
	GeeHashMap* _tmp1_;
	GeeHashMap* _tmp2_;
	GeeHashMap* _tmp3_;
	GeeHashMap* _tmp4_;
	GeeHashMap* _tmp5_;
	MailConversationListStore* _tmp6_;
	MailConversationListStore* _tmp7_;
	MailConversationListStore* _tmp8_;
	MailConversationListStore* _tmp9_;
	MailMoveHandler* _tmp10_;
	parent_class = G_OBJECT_CLASS (mail_conversation_list_box_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, MAIL_TYPE_CONVERSATION_LIST_BOX, MailConversationListBox);
	virtualizing_list_box_set_activate_on_single_click ((VirtualizingListBox*) self, TRUE);
	_tmp0_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, (GDestroyNotify) g_free, MAIL_TYPE_CONVERSATION_ITEM_MODEL, (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->conversations);
	self->priv->conversations = _tmp0_;
	_tmp1_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, (GDestroyNotify) g_free, camel_folder_get_type (), (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	_tmp2_ = _tmp1_;
	mail_conversation_list_box_set_folders (self, _tmp2_);
	_g_object_unref0 (_tmp2_);
	_tmp3_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, (GDestroyNotify) g_free, camel_folder_info_flags_get_type (), NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	_tmp4_ = _tmp3_;
	mail_conversation_list_box_set_folder_info_flags (self, _tmp4_);
	_g_object_unref0 (_tmp4_);
	_tmp5_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, (GDestroyNotify) g_free, camel_folder_thread_messages_get_type (), (GBoxedCopyFunc) camel_folder_thread_messages_ref, (GDestroyNotify) camel_folder_thread_messages_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->threads);
	self->priv->threads = _tmp5_;
	_tmp6_ = mail_conversation_list_store_new ();
	_g_object_unref0 (self->priv->list_store);
	self->priv->list_store = _tmp6_;
	_tmp7_ = self->priv->list_store;
	mail_conversation_list_store_set_sort_func (_tmp7_, _mail_conversation_list_box_thread_sort_function_gcompare_data_func, NULL);
	_tmp8_ = self->priv->list_store;
	mail_conversation_list_store_set_filter_func (_tmp8_, _mail_conversation_list_box_filter_function_mail_conversation_list_store_row_visibility_func, NULL);
	_tmp9_ = self->priv->list_store;
	virtualizing_list_box_set_model ((VirtualizingListBox*) self, (VirtualizingListBoxModel*) _tmp9_);
	_tmp10_ = mail_move_handler_new ();
	_mail_move_handler_unref0 (self->priv->move_handler);
	self->priv->move_handler = _tmp10_;
	(((VirtualizingListBox*) self)->factory_func_target_destroy_notify == NULL) ? NULL : (((VirtualizingListBox*) self)->factory_func_target_destroy_notify (((VirtualizingListBox*) self)->factory_func_target), NULL);
	((VirtualizingListBox*) self)->factory_func = NULL;
	((VirtualizingListBox*) self)->factory_func_target = NULL;
	((VirtualizingListBox*) self)->factory_func_target_destroy_notify = NULL;
	((VirtualizingListBox*) self)->factory_func = __mail_conversation_list_box___lambda32__virtualizing_list_box_row_factory_method;
	((VirtualizingListBox*) self)->factory_func_target = g_object_ref (self);
	((VirtualizingListBox*) self)->factory_func_target_destroy_notify = g_object_unref;
	g_signal_connect_object ((VirtualizingListBox*) self, "row-activated", (GCallback) __mail_conversation_list_box___lambda33__virtualizing_list_box_row_activated, self, 0);
	g_signal_connect_object ((VirtualizingListBox*) self, "row-selected", (GCallback) __mail_conversation_list_box___lambda35__virtualizing_list_box_row_selected, self, 0);
	g_signal_connect_object ((GtkWidget*) self, "button-release-event", (GCallback) __mail_conversation_list_box___lambda36__gtk_widget_button_release_event, self, 0);
	g_signal_connect_object ((GtkWidget*) self, "key-release-event", (GCallback) __mail_conversation_list_box___lambda37__gtk_widget_key_release_event, self, 0);
	return obj;
}

static void
mail_conversation_list_box_class_init (MailConversationListBoxClass * klass,
                                       gpointer klass_data)
{
	mail_conversation_list_box_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &MailConversationListBox_private_offset);
	G_OBJECT_CLASS (klass)->get_property = _vala_mail_conversation_list_box_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_mail_conversation_list_box_set_property;
	G_OBJECT_CLASS (klass)->constructor = mail_conversation_list_box_constructor;
	G_OBJECT_CLASS (klass)->finalize = mail_conversation_list_box_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), MAIL_CONVERSATION_LIST_BOX_FOLDER_FULL_NAME_PER_ACCOUNT_PROPERTY, mail_conversation_list_box_properties[MAIL_CONVERSATION_LIST_BOX_FOLDER_FULL_NAME_PER_ACCOUNT_PROPERTY] = g_param_spec_object ("folder-full-name-per-account", "folder-full-name-per-account", "folder-full-name-per-account", GEE_TYPE_MAP, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MAIL_CONVERSATION_LIST_BOX_FOLDERS_PROPERTY, mail_conversation_list_box_properties[MAIL_CONVERSATION_LIST_BOX_FOLDERS_PROPERTY] = g_param_spec_object ("folders", "folders", "folders", GEE_TYPE_HASH_MAP, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MAIL_CONVERSATION_LIST_BOX_FOLDER_INFO_FLAGS_PROPERTY, mail_conversation_list_box_properties[MAIL_CONVERSATION_LIST_BOX_FOLDER_INFO_FLAGS_PROPERTY] = g_param_spec_object ("folder-info-flags", "folder-info-flags", "folder-info-flags", GEE_TYPE_HASH_MAP, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	mail_conversation_list_box_signals[MAIL_CONVERSATION_LIST_BOX_CONVERSATION_SELECTED_SIGNAL] = g_signal_new ("conversation-selected", MAIL_TYPE_CONVERSATION_LIST_BOX, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__POINTER, G_TYPE_NONE, 1, G_TYPE_POINTER);
	mail_conversation_list_box_signals[MAIL_CONVERSATION_LIST_BOX_CONVERSATION_FOCUSED_SIGNAL] = g_signal_new ("conversation-focused", MAIL_TYPE_CONVERSATION_LIST_BOX, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__POINTER, G_TYPE_NONE, 1, G_TYPE_POINTER);
}

static void
mail_conversation_list_box_instance_init (MailConversationListBox * self,
                                          gpointer klass)
{
	self->priv = mail_conversation_list_box_get_instance_private (self);
	self->priv->cancellable = NULL;
	g_rec_mutex_init (&self->priv->__lock_threads);
	self->priv->current_search_query = NULL;
	self->priv->current_search_hide_read = FALSE;
	self->priv->current_search_hide_unstarred = FALSE;
	g_rec_mutex_init (&self->priv->__lock_conversations);
	self->priv->mark_read_timeout_id = (guint) 0;
	g_rec_mutex_init (&self->priv->__lock_folder_full_name_per_account);
	g_rec_mutex_init (&self->priv->__lock_folders);
}

static void
mail_conversation_list_box_finalize (GObject * obj)
{
	MailConversationListBox * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, MAIL_TYPE_CONVERSATION_LIST_BOX, MailConversationListBox);
	_g_object_unref0 (self->priv->_folder_full_name_per_account);
	_g_object_unref0 (self->priv->_folders);
	_g_object_unref0 (self->priv->_folder_info_flags);
	_g_object_unref0 (self->priv->cancellable);
	g_rec_mutex_clear (&self->priv->__lock_threads);
	_g_object_unref0 (self->priv->threads);
	_g_free0 (self->priv->current_search_query);
	g_rec_mutex_clear (&self->priv->__lock_conversations);
	_g_object_unref0 (self->priv->conversations);
	_g_object_unref0 (self->priv->list_store);
	_mail_move_handler_unref0 (self->priv->move_handler);
	g_rec_mutex_clear (&self->priv->__lock_folder_full_name_per_account);
	g_rec_mutex_clear (&self->priv->__lock_folders);
	G_OBJECT_CLASS (mail_conversation_list_box_parent_class)->finalize (obj);
}

static GType
mail_conversation_list_box_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (MailConversationListBoxClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) mail_conversation_list_box_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MailConversationListBox), 0, (GInstanceInitFunc) mail_conversation_list_box_instance_init, NULL };
	GType mail_conversation_list_box_type_id;
	mail_conversation_list_box_type_id = g_type_register_static (TYPE_VIRTUALIZING_LIST_BOX, "MailConversationListBox", &g_define_type_info, 0);
	MailConversationListBox_private_offset = g_type_add_instance_private (mail_conversation_list_box_type_id, sizeof (MailConversationListBoxPrivate));
	return mail_conversation_list_box_type_id;
}

GType
mail_conversation_list_box_get_type (void)
{
	static volatile gsize mail_conversation_list_box_type_id__once = 0;
	if (g_once_init_enter (&mail_conversation_list_box_type_id__once)) {
		GType mail_conversation_list_box_type_id;
		mail_conversation_list_box_type_id = mail_conversation_list_box_get_type_once ();
		g_once_init_leave (&mail_conversation_list_box_type_id__once, mail_conversation_list_box_type_id);
	}
	return mail_conversation_list_box_type_id__once;
}

static void
_vala_mail_conversation_list_box_get_property (GObject * object,
                                               guint property_id,
                                               GValue * value,
                                               GParamSpec * pspec)
{
	MailConversationListBox * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, MAIL_TYPE_CONVERSATION_LIST_BOX, MailConversationListBox);
	switch (property_id) {
		case MAIL_CONVERSATION_LIST_BOX_FOLDER_FULL_NAME_PER_ACCOUNT_PROPERTY:
		g_value_set_object (value, mail_conversation_list_box_get_folder_full_name_per_account (self));
		break;
		case MAIL_CONVERSATION_LIST_BOX_FOLDERS_PROPERTY:
		g_value_set_object (value, mail_conversation_list_box_get_folders (self));
		break;
		case MAIL_CONVERSATION_LIST_BOX_FOLDER_INFO_FLAGS_PROPERTY:
		g_value_set_object (value, mail_conversation_list_box_get_folder_info_flags (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_mail_conversation_list_box_set_property (GObject * object,
                                               guint property_id,
                                               const GValue * value,
                                               GParamSpec * pspec)
{
	MailConversationListBox * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, MAIL_TYPE_CONVERSATION_LIST_BOX, MailConversationListBox);
	switch (property_id) {
		case MAIL_CONVERSATION_LIST_BOX_FOLDER_FULL_NAME_PER_ACCOUNT_PROPERTY:
		mail_conversation_list_box_set_folder_full_name_per_account (self, g_value_get_object (value));
		break;
		case MAIL_CONVERSATION_LIST_BOX_FOLDERS_PROPERTY:
		mail_conversation_list_box_set_folders (self, g_value_get_object (value));
		break;
		case MAIL_CONVERSATION_LIST_BOX_FOLDER_INFO_FLAGS_PROPERTY:
		mail_conversation_list_box_set_folder_info_flags (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_array_destroy (gpointer array,
                     gssize array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		gssize i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_vala_array_free (gpointer array,
                  gssize array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

